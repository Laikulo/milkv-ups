diff -urpN --no-dereference -X diffgen.ignore test-tree/drivers/usb/core/hcd.c milky/drivers/usb/core/hcd.c
--- test-tree/drivers/usb/core/hcd.c	2024-06-01 13:18:41.872500285 -0400
+++ milky/drivers/usb/core/hcd.c	2024-05-21 05:22:27.000000000 -0400
@@ -2618,6 +2618,7 @@ static void usb_put_invalidate_rhdev(str
 	usb_put_dev(rhdev);
 }
 
+#if !defined(CONFIG_CVITEK_USB_LEGACY)
 /**
  * usb_add_hcd - finish generic HCD structure initialization and register
  * @hcd: the usb_hcd structure to initialize
@@ -2902,6 +2903,336 @@ void usb_remove_hcd(struct usb_hcd *hcd)
 }
 EXPORT_SYMBOL_GPL(usb_remove_hcd);
 
+#else
+/**
+ * usb_otg_add_hcd - finish generic HCD structure initialization and register
+ * @hcd: the usb_hcd structure to initialize
+ * @irqnum: Interrupt line to allocate
+ * @irqflags: Interrupt type flags
+ *
+ * Finish the remaining parts of generic HCD initialization: allocate the
+ * buffers of consistent memory, register the bus, request the IRQ line,
+ * and call the driver's reset() and start() routines.
+ */
+static int usb_otg_add_hcd(struct usb_hcd *hcd,
+			   unsigned int irqnum, unsigned long irqflags)
+{
+	int retval;
+	struct usb_device *rhdev;
+
+	if (!hcd->skip_phy_initialization && usb_hcd_is_primary_hcd(hcd)) {
+		hcd->phy_roothub = usb_phy_roothub_alloc(hcd->self.sysdev);
+		if (IS_ERR(hcd->phy_roothub))
+			return PTR_ERR(hcd->phy_roothub);
+
+		retval = usb_phy_roothub_init(hcd->phy_roothub);
+		if (retval)
+			return retval;
+
+		retval = usb_phy_roothub_power_on(hcd->phy_roothub);
+		if (retval)
+			goto err_usb_phy_roothub_power_on;
+	}
+
+	dev_info(hcd->self.controller, "%s\n", hcd->product_desc);
+
+	/* Keep old behaviour if authorized_default is not in [0, 1]. */
+	if (authorized_default < 0 || authorized_default > 1) {
+		if (hcd->wireless)
+			clear_bit(HCD_FLAG_DEV_AUTHORIZED, &hcd->flags);
+		else
+			set_bit(HCD_FLAG_DEV_AUTHORIZED, &hcd->flags);
+	} else {
+		if (authorized_default)
+			set_bit(HCD_FLAG_DEV_AUTHORIZED, &hcd->flags);
+		else
+			clear_bit(HCD_FLAG_DEV_AUTHORIZED, &hcd->flags);
+	}
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+
+	/* per default all interfaces are authorized */
+	set_bit(HCD_FLAG_INTF_AUTHORIZED, &hcd->flags);
+
+	/* HC is in reset state, but accessible.  Now do the one-time init,
+	 * bottom up so that hcds can customize the root hubs before hub_wq
+	 * starts talking to them.  (Note, bus id is assigned early too.)
+	 */
+	retval = hcd_buffer_create(hcd);
+	if (retval != 0) {
+		dev_dbg(hcd->self.sysdev, "pool alloc failed\n");
+		goto err_create_buf;
+	}
+
+	retval = usb_register_bus(&hcd->self);
+	if (retval < 0)
+		goto err_register_bus;
+
+	rhdev = usb_alloc_dev(NULL, &hcd->self, 0);
+	if (rhdev == NULL) {
+		dev_err(hcd->self.sysdev, "unable to allocate root hub\n");
+		retval = -ENOMEM;
+		goto err_allocate_root_hub;
+	}
+	mutex_lock(&usb_port_peer_mutex);
+	hcd->self.root_hub = rhdev;
+	mutex_unlock(&usb_port_peer_mutex);
+
+	rhdev->rx_lanes = 1;
+	rhdev->tx_lanes = 1;
+
+	switch (hcd->speed) {
+	case HCD_USB11:
+		rhdev->speed = USB_SPEED_FULL;
+		break;
+	case HCD_USB2:
+		rhdev->speed = USB_SPEED_HIGH;
+		break;
+	case HCD_USB25:
+		rhdev->speed = USB_SPEED_WIRELESS;
+		break;
+	case HCD_USB3:
+		rhdev->speed = USB_SPEED_SUPER;
+		break;
+	case HCD_USB32:
+		rhdev->rx_lanes = 2;
+		rhdev->tx_lanes = 2;
+		/* fall through */
+	case HCD_USB31:
+		rhdev->speed = USB_SPEED_SUPER_PLUS;
+		break;
+	default:
+		retval = -EINVAL;
+		goto err_set_rh_speed;
+	}
+
+	/* wakeup flag init defaults to "everything works" for root hubs,
+	 * but drivers can override it in reset() if needed, along with
+	 * recording the overall controller's system wakeup capability.
+	 */
+	device_set_wakeup_capable(&rhdev->dev, 1);
+
+	/* HCD_FLAG_RH_RUNNING doesn't matter until the root hub is
+	 * registered.  But since the controller can die at any time,
+	 * let's initialize the flag before touching the hardware.
+	 */
+	set_bit(HCD_FLAG_RH_RUNNING, &hcd->flags);
+
+	/* "reset" is misnamed; its role is now one-time init. the controller
+	 * should already have been reset (and boot firmware kicked off etc).
+	 */
+	if (hcd->driver->reset) {
+		retval = hcd->driver->reset(hcd);
+		if (retval < 0) {
+			dev_err(hcd->self.controller, "can't setup: %d\n",
+					retval);
+			goto err_hcd_driver_setup;
+		}
+	}
+	hcd->rh_pollable = 1;
+
+	/* NOTE: root hub and controller capabilities may not be the same */
+	if (device_can_wakeup(hcd->self.controller)
+			&& device_can_wakeup(&hcd->self.root_hub->dev))
+		dev_dbg(hcd->self.controller, "supports USB remote wakeup\n");
+
+	/* initialize tasklets */
+	init_giveback_urb_bh(&hcd->high_prio_bh);
+	init_giveback_urb_bh(&hcd->low_prio_bh);
+
+	/* enable irqs just before we start the controller,
+	 * if the BIOS provides legacy PCI irqs.
+	 */
+	if (usb_hcd_is_primary_hcd(hcd) && irqnum) {
+		retval = usb_hcd_request_irqs(hcd, irqnum, irqflags);
+		if (retval)
+			goto err_request_irq;
+	}
+
+	hcd->state = HC_STATE_RUNNING;
+	retval = hcd->driver->start(hcd);
+	if (retval < 0) {
+		dev_err(hcd->self.controller, "startup error %d\n", retval);
+		goto err_hcd_driver_start;
+	}
+
+	/* starting here, usbcore will pay attention to this root hub */
+	retval = register_root_hub(hcd);
+	if (retval != 0)
+		goto err_register_root_hub;
+
+	retval = sysfs_create_group(&rhdev->dev.kobj, &usb_bus_attr_group);
+	if (retval < 0) {
+		dev_err(hcd->self.controller, "Cannot register USB bus sysfs attributes: %d\n",
+		       retval);
+		goto error_create_attr_group;
+	}
+	if (hcd->uses_new_polling && HCD_POLL_RH(hcd))
+		usb_hcd_poll_rh_status(hcd);
+
+	return retval;
+
+error_create_attr_group:
+	clear_bit(HCD_FLAG_RH_RUNNING, &hcd->flags);
+	if (HC_IS_RUNNING(hcd->state))
+		hcd->state = HC_STATE_QUIESCING;
+	spin_lock_irq(&hcd_root_hub_lock);
+	hcd->rh_registered = 0;
+	spin_unlock_irq(&hcd_root_hub_lock);
+
+#ifdef CONFIG_PM
+	cancel_work_sync(&hcd->wakeup_work);
+#endif
+	mutex_lock(&usb_bus_idr_lock);
+	usb_disconnect(&rhdev);		/* Sets rhdev to NULL */
+	mutex_unlock(&usb_bus_idr_lock);
+err_register_root_hub:
+	hcd->rh_pollable = 0;
+	clear_bit(HCD_FLAG_POLL_RH, &hcd->flags);
+	del_timer_sync(&hcd->rh_timer);
+	hcd->driver->stop(hcd);
+	hcd->state = HC_STATE_HALT;
+	clear_bit(HCD_FLAG_POLL_RH, &hcd->flags);
+	del_timer_sync(&hcd->rh_timer);
+err_hcd_driver_start:
+	if (usb_hcd_is_primary_hcd(hcd) && hcd->irq > 0)
+		free_irq(irqnum, hcd);
+err_request_irq:
+err_hcd_driver_setup:
+err_set_rh_speed:
+	usb_put_invalidate_rhdev(hcd);
+err_allocate_root_hub:
+	usb_deregister_bus(&hcd->self);
+err_register_bus:
+	hcd_buffer_destroy(hcd);
+err_create_buf:
+	usb_phy_roothub_power_off(hcd->phy_roothub);
+err_usb_phy_roothub_power_on:
+	usb_phy_roothub_exit(hcd->phy_roothub);
+
+	return retval;
+}
+
+/**
+ * usb_otg_remove_hcd - shutdown processing for generic HCDs
+ * @hcd: the usb_hcd structure to remove
+ * Context: !in_interrupt()
+ *
+ * Disconnects the root hub, then reverses the effects of usb_add_hcd(),
+ * invoking the HCD's stop() method.
+ */
+static void usb_otg_remove_hcd(struct usb_hcd *hcd)
+{
+	struct usb_device *rhdev = hcd->self.root_hub;
+
+	dev_info(hcd->self.controller, "remove, state %x\n", hcd->state);
+
+	usb_get_dev(rhdev);
+	sysfs_remove_group(&rhdev->dev.kobj, &usb_bus_attr_group);
+
+	clear_bit(HCD_FLAG_RH_RUNNING, &hcd->flags);
+	if (HC_IS_RUNNING(hcd->state))
+		hcd->state = HC_STATE_QUIESCING;
+
+	dev_dbg(hcd->self.controller, "roothub graceful disconnect\n");
+	spin_lock_irq(&hcd_root_hub_lock);
+	hcd->rh_registered = 0;
+	spin_unlock_irq(&hcd_root_hub_lock);
+
+#ifdef CONFIG_PM
+	cancel_work_sync(&hcd->wakeup_work);
+#endif
+
+	mutex_lock(&usb_bus_idr_lock);
+	usb_disconnect(&rhdev);		/* Sets rhdev to NULL */
+	mutex_unlock(&usb_bus_idr_lock);
+
+	/*
+	 * tasklet_kill() isn't needed here because:
+	 * - driver's disconnect() called from usb_disconnect() should
+	 *   make sure its URBs are completed during the disconnect()
+	 *   callback
+	 *
+	 * - it is too late to run complete() here since driver may have
+	 *   been removed already now
+	 */
+
+	/* Prevent any more root-hub status calls from the timer.
+	 * The HCD might still restart the timer (if a port status change
+	 * interrupt occurs), but usb_hcd_poll_rh_status() won't invoke
+	 * the hub_status_data() callback.
+	 */
+	hcd->rh_pollable = 0;
+	clear_bit(HCD_FLAG_POLL_RH, &hcd->flags);
+	del_timer_sync(&hcd->rh_timer);
+
+	hcd->driver->stop(hcd);
+	hcd->state = HC_STATE_HALT;
+
+	/* In case the HCD restarted the timer, stop it again. */
+	clear_bit(HCD_FLAG_POLL_RH, &hcd->flags);
+	del_timer_sync(&hcd->rh_timer);
+
+	if (usb_hcd_is_primary_hcd(hcd)) {
+		if (hcd->irq > 0)
+			free_irq(hcd->irq, hcd);
+	}
+
+	usb_deregister_bus(&hcd->self);
+	hcd_buffer_destroy(hcd);
+
+	usb_phy_roothub_power_off(hcd->phy_roothub);
+	usb_phy_roothub_exit(hcd->phy_roothub);
+
+	usb_put_invalidate_rhdev(hcd);
+	hcd->flags = 0;
+}
+
+static struct otg_hcd_ops otg_hcd_intf = {
+	.add = usb_otg_add_hcd,
+	.remove = usb_otg_remove_hcd,
+};
+
+/**
+ * usb_add_hcd - finish generic HCD structure initialization and register
+ * @hcd: the usb_hcd structure to initialize
+ * @irqnum: Interrupt line to allocate
+ * @irqflags: Interrupt type flags
+ *
+ * Finish the remaining parts of generic HCD initialization: allocate the
+ * buffers of consistent memory, register the bus, request the IRQ line,
+ * and call the driver's reset() and start() routines.
+ * If it is an OTG device then it only registers the HCD with OTG core.
+ *
+ */
+int usb_add_hcd(struct usb_hcd *hcd,
+		unsigned int irqnum, unsigned long irqflags)
+{
+	/* If OTG device, OTG core takes care of adding HCD */
+	if (usb_otg_register_hcd(hcd, irqnum, irqflags, &otg_hcd_intf))
+		return usb_otg_add_hcd(hcd, irqnum, irqflags);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(usb_add_hcd);
+
+/**
+ * usb_remove_hcd - shutdown processing for generic HCDs
+ * @hcd: the usb_hcd structure to remove
+ * Context: !in_interrupt()
+ *
+ * Disconnects the root hub, then reverses the effects of usb_add_hcd(),
+ * invoking the HCD's stop() method.
+ * If it is an OTG device then it unregisters the HCD from OTG core
+ * as well.
+ */
+void usb_remove_hcd(struct usb_hcd *hcd)
+{
+	/* If OTG device, OTG core takes care of stopping HCD */
+	if (usb_otg_unregister_hcd(hcd))
+		usb_otg_remove_hcd(hcd);
+}
+EXPORT_SYMBOL_GPL(usb_remove_hcd);
+
+#endif
 void
 usb_hcd_platform_shutdown(struct platform_device *dev)
 {
diff -urpN --no-dereference -X diffgen.ignore test-tree/drivers/usb/dwc2/core.c milky/drivers/usb/dwc2/core.c
--- test-tree/drivers/usb/dwc2/core.c	2024-06-01 13:18:41.872500285 -0400
+++ milky/drivers/usb/dwc2/core.c	2024-05-21 05:22:27.000000000 -0400
@@ -131,54 +131,26 @@ int dwc2_restore_global_registers(struct
  * dwc2_exit_partial_power_down() - Exit controller from Partial Power Down.
  *
  * @hsotg: Programming view of the DWC_otg controller
+ * @rem_wakeup: indicates whether resume is initiated by Reset.
  * @restore: Controller registers need to be restored
  */
-int dwc2_exit_partial_power_down(struct dwc2_hsotg *hsotg, bool restore)
+int dwc2_exit_partial_power_down(struct dwc2_hsotg *hsotg, int rem_wakeup,
+				 bool restore)
 {
-	u32 pcgcctl;
-	int ret = 0;
-
-	if (hsotg->params.power_down != DWC2_POWER_DOWN_PARAM_PARTIAL)
-		return -ENOTSUPP;
-
-	pcgcctl = dwc2_readl(hsotg, PCGCTL);
-	pcgcctl &= ~PCGCTL_STOPPCLK;
-	dwc2_writel(hsotg, pcgcctl, PCGCTL);
-
-	pcgcctl = dwc2_readl(hsotg, PCGCTL);
-	pcgcctl &= ~PCGCTL_PWRCLMP;
-	dwc2_writel(hsotg, pcgcctl, PCGCTL);
-
-	pcgcctl = dwc2_readl(hsotg, PCGCTL);
-	pcgcctl &= ~PCGCTL_RSTPDWNMODULE;
-	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+	struct dwc2_gregs_backup *gr;
 
-	udelay(100);
-	if (restore) {
-		ret = dwc2_restore_global_registers(hsotg);
-		if (ret) {
-			dev_err(hsotg->dev, "%s: failed to restore registers\n",
-				__func__);
-			return ret;
-		}
-		if (dwc2_is_host_mode(hsotg)) {
-			ret = dwc2_restore_host_registers(hsotg);
-			if (ret) {
-				dev_err(hsotg->dev, "%s: failed to restore host registers\n",
-					__func__);
-				return ret;
-			}
-		} else {
-			ret = dwc2_restore_device_registers(hsotg, 0);
-			if (ret) {
-				dev_err(hsotg->dev, "%s: failed to restore device registers\n",
-					__func__);
-				return ret;
-			}
-		}
-	}
+	gr = &hsotg->gr_backup;
 
-	return ret;
+	/*
+	 * Restore host or device regisers with the same mode core enterted
+	 * to partial power down by checking "GOTGCTL_CURMODE_HOST" backup
+	 * value of the "gotgctl" register.
+	 */
+	if (gr->gotgctl & GOTGCTL_CURMODE_HOST)
+		return dwc2_host_exit_partial_power_down(hsotg, rem_wakeup,
+							 restore);
+	else
+		return dwc2_gadget_exit_partial_power_down(hsotg, restore);
 }
 
 /**
@@ -188,57 +160,10 @@ int dwc2_exit_partial_power_down(struct
  */
 int dwc2_enter_partial_power_down(struct dwc2_hsotg *hsotg)
 {
-	u32 pcgcctl;
-	int ret = 0;
-
-	if (!hsotg->params.power_down)
-		return -ENOTSUPP;
-
-	/* Backup all registers */
-	ret = dwc2_backup_global_registers(hsotg);
-	if (ret) {
-		dev_err(hsotg->dev, "%s: failed to backup global registers\n",
-			__func__);
-		return ret;
-	}
-
-	if (dwc2_is_host_mode(hsotg)) {
-		ret = dwc2_backup_host_registers(hsotg);
-		if (ret) {
-			dev_err(hsotg->dev, "%s: failed to backup host registers\n",
-				__func__);
-			return ret;
-		}
-	} else {
-		ret = dwc2_backup_device_registers(hsotg);
-		if (ret) {
-			dev_err(hsotg->dev, "%s: failed to backup device registers\n",
-				__func__);
-			return ret;
-		}
-	}
-
-	/*
-	 * Clear any pending interrupts since dwc2 will not be able to
-	 * clear them after entering partial_power_down.
-	 */
-	dwc2_writel(hsotg, 0xffffffff, GINTSTS);
-
-	/* Put the controller in low power state */
-	pcgcctl = dwc2_readl(hsotg, PCGCTL);
-
-	pcgcctl |= PCGCTL_PWRCLMP;
-	dwc2_writel(hsotg, pcgcctl, PCGCTL);
-	ndelay(20);
-
-	pcgcctl |= PCGCTL_RSTPDWNMODULE;
-	dwc2_writel(hsotg, pcgcctl, PCGCTL);
-	ndelay(20);
-
-	pcgcctl |= PCGCTL_STOPPCLK;
-	dwc2_writel(hsotg, pcgcctl, PCGCTL);
-
-	return ret;
+	if (dwc2_is_host_mode(hsotg))
+		return dwc2_host_enter_partial_power_down(hsotg);
+	else
+		return dwc2_gadget_enter_partial_power_down(hsotg);
 }
 
 /**
@@ -374,6 +299,12 @@ void dwc2_hib_restore_common(struct dwc2
 			__func__);
 	} else {
 		dev_dbg(hsotg->dev, "restore done  generated here\n");
+
+		/*
+		 * To avoid restore done interrupt storm after restore is
+		 * generated clear GINTSTS_RESTOREDONE bit.
+		 */
+		dwc2_writel(hsotg, GINTSTS_RESTOREDONE, GINTSTS);
 	}
 }
 
@@ -460,9 +391,6 @@ static bool dwc2_iddig_filter_enabled(st
  */
 int dwc2_enter_hibernation(struct dwc2_hsotg *hsotg, int is_host)
 {
-	if (hsotg->params.power_down != DWC2_POWER_DOWN_PARAM_HIBERNATION)
-		return -ENOTSUPP;
-
 	if (is_host)
 		return dwc2_host_enter_hibernation(hsotg);
 	else
@@ -545,6 +473,22 @@ int dwc2_core_reset(struct dwc2_hsotg *h
 		dwc2_writel(hsotg, greset, GRSTCTL);
 	}
 
+	/*
+	 * Switching from device mode to host mode by disconnecting
+	 * device cable core enters and exits form hibernation.
+	 * However, the fifo map remains not cleared. It results
+	 * to a WARNING (WARNING: CPU: 5 PID: 0 at drivers/usb/dwc2/
+	 * gadget.c:307 dwc2_hsotg_init_fifo+0x12/0x152 [dwc2])
+	 * if in host mode we disconnect the micro a to b host
+	 * cable. Because core reset occurs.
+	 * To avoid the WARNING, fifo_map should be cleared
+	 * in dwc2_core_reset() function by taking into account configs.
+	 * fifo_map must be cleared only if driver is configured in
+	 * "CONFIG_USB_DWC2_PERIPHERAL" or "CONFIG_USB_DWC2_DUAL_ROLE"
+	 * mode.
+	 */
+	dwc2_clear_fifo_map(hsotg);
+
 	/* Wait for AHB master IDLE state */
 	if (dwc2_hsotg_wait_bit_set(hsotg, GRSTCTL, GRSTCTL_AHBIDLE, 10000)) {
 		dev_warn(hsotg->dev, "%s: HANG! AHB Idle timeout GRSTCTL GRSTCTL_AHBIDLE\n",
diff -urpN --no-dereference -X diffgen.ignore test-tree/drivers/usb/dwc2/core.h milky/drivers/usb/dwc2/core.h
--- test-tree/drivers/usb/dwc2/core.h	2024-06-01 13:18:41.872500285 -0400
+++ milky/drivers/usb/dwc2/core.h	2024-05-21 05:22:27.000000000 -0400
@@ -112,6 +112,7 @@ struct dwc2_hsotg_req;
  * @debugfs: File entry for debugfs file for this endpoint.
  * @dir_in: Set to true if this endpoint is of the IN direction, which
  *          means that it is sending data to the Host.
+ * @map_dir: Set to the value of dir_in when the DMA buffer is mapped.
  * @index: The index for the endpoint registers.
  * @mc: Multi Count - number of transactions per microframe
  * @interval: Interval for periodic endpoints, in frames or microframes.
@@ -161,6 +162,7 @@ struct dwc2_hsotg_ep {
 	unsigned short		fifo_index;
 
 	unsigned char           dir_in;
+	unsigned char           map_dir;
 	unsigned char           index;
 	unsigned char           mc;
 	u16                     interval;
@@ -426,7 +428,7 @@ enum dwc2_ep0_state {
  * @g_tx_fifo_size:	An array of TX fifo sizes in dedicated fifo
  *			mode. Each value corresponds to one EP
  *			starting from EP1 (max 15 values). Sizes are
- *			in DWORDS with possible values from from
+ *			in DWORDS with possible values from
  *			16-32768 (default: 256, 256, 256, 256, 768,
  *			768, 768, 768, 0, 0, 0, 0, 0, 0, 0).
  * @change_speed_quirk: Change speed configuration to DWC2_SPEED_PARAM_FULL
@@ -841,6 +843,37 @@ struct dwc2_hregs_backup {
 #define DWC2_LS_SCHEDULE_SLICES	(DWC2_LS_SCHEDULE_FRAMES * \
 				 DWC2_LS_PERIODIC_SLICES_PER_FRAME)
 
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+
+enum CHG_PORT_E {
+	CHGDET_SDP,	/* standard downstream port. */
+	CHGDET_DCP,	/* dedicated charging port. */
+	CHGDET_CDP,	/* charging downstream port. */
+	CHGDET_NUM
+};
+
+struct cvi_usb_clk {
+	int				is_on;
+	struct clk			*clk_o;
+};
+
+struct cviusb_dev {
+	void __iomem *phy_regs;
+	void __iomem *usb_pin_regs;
+	struct cvi_usb_clk	clk_axi;
+	struct cvi_usb_clk	clk_apb;
+	struct cvi_usb_clk	clk_125m;
+	struct cvi_usb_clk	clk_33k;
+	struct cvi_usb_clk	clk_12m;
+	int			vbus_pin;
+	int			vbus_pin_inverted;
+	int			pre_vbus_status;
+	int			id_override;
+	u8			dcd_dis;
+	u8			chgdet;
+};
+#endif
+
 /**
  * struct dwc2_hsotg - Holds the state of the driver, including the non-periodic
  * and periodic schedules
@@ -865,6 +898,8 @@ struct dwc2_hregs_backup {
  * @gadget_enabled:	Peripheral mode sub-driver initialization indicator.
  * @ll_hw_enabled:	Status of low-level hardware resources.
  * @hibernated:		True if core is hibernated
+ * @in_ppd:		True if core is partial power down mode.
+ * @bus_suspended:	True if bus is suspended
  * @reset_phy_on_wake:	Quirk saying that we should assert PHY reset on a
  *			remote wakeup.
  * @phy_off_for_suspend: Status of whether we turned the PHY off at suspend.
@@ -1022,7 +1057,6 @@ struct dwc2_hregs_backup {
  *			a pointer to an array of register definitions, the
  *			array size and the base address where the register bank
  *			is to be found.
- * @bus_suspended:	True if bus is suspended
  * @last_frame_num:	Number of last frame. Range from 0 to  32768
  * @frame_num_array:    Used only  if CONFIG_USB_DWC2_TRACK_MISSED_SOFS is
  *			defined, for missed SOFs tracking. Array holds that
@@ -1060,6 +1094,8 @@ struct dwc2_hsotg {
 	unsigned int gadget_enabled:1;
 	unsigned int ll_hw_enabled:1;
 	unsigned int hibernated:1;
+	unsigned int in_ppd:1;
+	bool bus_suspended;
 	unsigned int reset_phy_on_wake:1;
 	unsigned int need_phy_for_wake:1;
 	unsigned int phy_off_for_suspend:1;
@@ -1143,7 +1179,6 @@ struct dwc2_hsotg {
 	unsigned long hs_periodic_bitmap[
 		DIV_ROUND_UP(DWC2_HS_SCHEDULE_US, BITS_PER_LONG)];
 	u16 periodic_qh_count;
-	bool bus_suspended;
 	bool new_connection;
 
 	u16 last_frame_num;
@@ -1210,6 +1245,9 @@ struct dwc2_hsotg {
 	struct dwc2_hsotg_ep *eps_in[MAX_EPS_CHANNELS];
 	struct dwc2_hsotg_ep *eps_out[MAX_EPS_CHANNELS];
 #endif /* CONFIG_USB_DWC2_PERIPHERAL || CONFIG_USB_DWC2_DUAL_ROLE */
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	struct cviusb_dev cviusb;
+#endif
 };
 
 /* Normal architectures just use readl/write */
@@ -1295,13 +1333,28 @@ static inline bool dwc2_is_hs_iot(struct
 	return (hsotg->hw_params.snpsid & 0xffff0000) == 0x55320000;
 }
 
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+/* cviusb readl/write */
+static inline u32 cviusb_readl(const void __iomem *addr)
+{
+	return readl(addr);
+}
+
+static inline void cviusb_writel(u32 value, void __iomem *addr)
+{
+	writel(value, addr);
+}
+
+#endif
+
 /*
  * The following functions support initialization of the core driver component
  * and the DWC_otg controller
  */
 int dwc2_core_reset(struct dwc2_hsotg *hsotg, bool skip_wait);
 int dwc2_enter_partial_power_down(struct dwc2_hsotg *hsotg);
-int dwc2_exit_partial_power_down(struct dwc2_hsotg *hsotg, bool restore);
+int dwc2_exit_partial_power_down(struct dwc2_hsotg *hsotg, int rem_wakeup,
+				 bool restore);
 int dwc2_enter_hibernation(struct dwc2_hsotg *hsotg, int is_host);
 int dwc2_exit_hibernation(struct dwc2_hsotg *hsotg, int rem_wakeup,
 		int reset, int is_host);
@@ -1409,11 +1462,19 @@ int dwc2_restore_device_registers(struct
 int dwc2_gadget_enter_hibernation(struct dwc2_hsotg *hsotg);
 int dwc2_gadget_exit_hibernation(struct dwc2_hsotg *hsotg,
 				 int rem_wakeup, int reset);
+int dwc2_gadget_enter_partial_power_down(struct dwc2_hsotg *hsotg);
+int dwc2_gadget_exit_partial_power_down(struct dwc2_hsotg *hsotg,
+					bool restore);
+void dwc2_gadget_enter_clock_gating(struct dwc2_hsotg *hsotg);
+void dwc2_gadget_exit_clock_gating(struct dwc2_hsotg *hsotg,
+				   int rem_wakeup);
 int dwc2_hsotg_tx_fifo_count(struct dwc2_hsotg *hsotg);
 int dwc2_hsotg_tx_fifo_total_depth(struct dwc2_hsotg *hsotg);
 int dwc2_hsotg_tx_fifo_average_depth(struct dwc2_hsotg *hsotg);
 void dwc2_gadget_init_lpm(struct dwc2_hsotg *hsotg);
 void dwc2_gadget_program_ref_clk(struct dwc2_hsotg *hsotg);
+static inline void dwc2_clear_fifo_map(struct dwc2_hsotg *hsotg)
+{ hsotg->fifo_map = 0; }
 #else
 static inline int dwc2_hsotg_remove(struct dwc2_hsotg *dwc2)
 { return 0; }
@@ -1442,6 +1503,14 @@ static inline int dwc2_gadget_enter_hibe
 static inline int dwc2_gadget_exit_hibernation(struct dwc2_hsotg *hsotg,
 					       int rem_wakeup, int reset)
 { return 0; }
+static inline int dwc2_gadget_enter_partial_power_down(struct dwc2_hsotg *hsotg)
+{ return 0; }
+static inline int dwc2_gadget_exit_partial_power_down(struct dwc2_hsotg *hsotg,
+						      bool restore)
+{ return 0; }
+static inline void dwc2_gadget_enter_clock_gating(struct dwc2_hsotg *hsotg) {}
+static inline void dwc2_gadget_exit_clock_gating(struct dwc2_hsotg *hsotg,
+						 int rem_wakeup) {}
 static inline int dwc2_hsotg_tx_fifo_count(struct dwc2_hsotg *hsotg)
 { return 0; }
 static inline int dwc2_hsotg_tx_fifo_total_depth(struct dwc2_hsotg *hsotg)
@@ -1450,6 +1519,7 @@ static inline int dwc2_hsotg_tx_fifo_ave
 { return 0; }
 static inline void dwc2_gadget_init_lpm(struct dwc2_hsotg *hsotg) {}
 static inline void dwc2_gadget_program_ref_clk(struct dwc2_hsotg *hsotg) {}
+static inline void dwc2_clear_fifo_map(struct dwc2_hsotg *hsotg) {}
 #endif
 
 #if IS_ENABLED(CONFIG_USB_DWC2_HOST) || IS_ENABLED(CONFIG_USB_DWC2_DUAL_ROLE)
@@ -1459,11 +1529,18 @@ void dwc2_hcd_connect(struct dwc2_hsotg
 void dwc2_hcd_disconnect(struct dwc2_hsotg *hsotg, bool force);
 void dwc2_hcd_start(struct dwc2_hsotg *hsotg);
 int dwc2_core_init(struct dwc2_hsotg *hsotg, bool initial_setup);
+int dwc2_port_suspend(struct dwc2_hsotg *hsotg, u16 windex);
+int dwc2_port_resume(struct dwc2_hsotg *hsotg);
 int dwc2_backup_host_registers(struct dwc2_hsotg *hsotg);
 int dwc2_restore_host_registers(struct dwc2_hsotg *hsotg);
 int dwc2_host_enter_hibernation(struct dwc2_hsotg *hsotg);
 int dwc2_host_exit_hibernation(struct dwc2_hsotg *hsotg,
 			       int rem_wakeup, int reset);
+int dwc2_host_enter_partial_power_down(struct dwc2_hsotg *hsotg);
+int dwc2_host_exit_partial_power_down(struct dwc2_hsotg *hsotg,
+				      int rem_wakeup, bool restore);
+void dwc2_host_enter_clock_gating(struct dwc2_hsotg *hsotg);
+void dwc2_host_exit_clock_gating(struct dwc2_hsotg *hsotg, int rem_wakeup);
 bool dwc2_host_can_poweroff_phy(struct dwc2_hsotg *dwc2);
 static inline void dwc2_host_schedule_phy_reset(struct dwc2_hsotg *hsotg)
 { schedule_work(&hsotg->phy_reset_work); }
@@ -1479,6 +1556,10 @@ static inline void dwc2_hcd_start(struct
 static inline void dwc2_hcd_remove(struct dwc2_hsotg *hsotg) {}
 static inline int dwc2_core_init(struct dwc2_hsotg *hsotg, bool initial_setup)
 { return 0; }
+static inline int dwc2_port_suspend(struct dwc2_hsotg *hsotg, u16 windex)
+{ return 0; }
+static inline int dwc2_port_resume(struct dwc2_hsotg *hsotg)
+{ return 0; }
 static inline int dwc2_hcd_init(struct dwc2_hsotg *hsotg)
 { return 0; }
 static inline int dwc2_backup_host_registers(struct dwc2_hsotg *hsotg)
@@ -1490,6 +1571,14 @@ static inline int dwc2_host_enter_hibern
 static inline int dwc2_host_exit_hibernation(struct dwc2_hsotg *hsotg,
 					     int rem_wakeup, int reset)
 { return 0; }
+static inline int dwc2_host_enter_partial_power_down(struct dwc2_hsotg *hsotg)
+{ return 0; }
+static inline int dwc2_host_exit_partial_power_down(struct dwc2_hsotg *hsotg,
+						    int rem_wakeup, bool restore)
+{ return 0; }
+static inline void dwc2_host_enter_clock_gating(struct dwc2_hsotg *hsotg) {}
+static inline void dwc2_host_exit_clock_gating(struct dwc2_hsotg *hsotg,
+					       int rem_wakeup) {}
 static inline bool dwc2_host_can_poweroff_phy(struct dwc2_hsotg *dwc2)
 { return false; }
 static inline void dwc2_host_schedule_phy_reset(struct dwc2_hsotg *hsotg) {}
diff -urpN --no-dereference -X diffgen.ignore test-tree/drivers/usb/dwc2/core_intr.c milky/drivers/usb/dwc2/core_intr.c
--- test-tree/drivers/usb/dwc2/core_intr.c	2024-06-01 13:18:41.872500285 -0400
+++ milky/drivers/usb/dwc2/core_intr.c	2024-05-21 05:22:27.000000000 -0400
@@ -307,6 +307,7 @@ static void dwc2_handle_conn_id_status_c
 static void dwc2_handle_session_req_intr(struct dwc2_hsotg *hsotg)
 {
 	int ret;
+	u32 hprt0;
 
 	/* Clear interrupt */
 	dwc2_writel(hsotg, GINTSTS_SESSREQINT, GINTSTS);
@@ -316,10 +317,18 @@ static void dwc2_handle_session_req_intr
 
 	if (dwc2_is_device_mode(hsotg)) {
 		if (hsotg->lx_state == DWC2_L2) {
-			ret = dwc2_exit_partial_power_down(hsotg, true);
-			if (ret && (ret != -ENOTSUPP))
-				dev_err(hsotg->dev,
-					"exit power_down failed\n");
+			if (hsotg->in_ppd) {
+				ret = dwc2_exit_partial_power_down(hsotg, 0,
+								   true);
+				if (ret)
+					dev_err(hsotg->dev,
+						"exit power_down failed\n");
+			}
+
+			/* Exit gadget mode clock gating. */
+			if (hsotg->params.power_down ==
+			    DWC2_POWER_DOWN_PARAM_NONE && hsotg->bus_suspended)
+				dwc2_gadget_exit_clock_gating(hsotg, 0);
 		}
 
 		/*
@@ -327,6 +336,13 @@ static void dwc2_handle_session_req_intr
 		 * established
 		 */
 		dwc2_hsotg_disconnect(hsotg);
+	} else {
+		/* Turn on the port power bit. */
+		hprt0 = dwc2_read_hprt0(hsotg);
+		hprt0 |= HPRT0_PWR;
+		dwc2_writel(hsotg, hprt0, HPRT0);
+		/* Connect hcd after port power is set. */
+		dwc2_hcd_connect(hsotg);
 	}
 }
 
@@ -407,32 +423,40 @@ static void dwc2_handle_wakeup_detected_
 		dev_dbg(hsotg->dev, "DSTS=0x%0x\n",
 			dwc2_readl(hsotg, DSTS));
 		if (hsotg->lx_state == DWC2_L2) {
-			u32 dctl = dwc2_readl(hsotg, DCTL);
-
-			/* Clear Remote Wakeup Signaling */
-			dctl &= ~DCTL_RMTWKUPSIG;
-			dwc2_writel(hsotg, dctl, DCTL);
-			ret = dwc2_exit_partial_power_down(hsotg, true);
-			if (ret && (ret != -ENOTSUPP))
-				dev_err(hsotg->dev, "exit power_down failed\n");
+			if (hsotg->in_ppd) {
+				u32 dctl = dwc2_readl(hsotg, DCTL);
+				/* Clear Remote Wakeup Signaling */
+				dctl &= ~DCTL_RMTWKUPSIG;
+				dwc2_writel(hsotg, dctl, DCTL);
+				ret = dwc2_exit_partial_power_down(hsotg, 1,
+								   true);
+				if (ret)
+					dev_err(hsotg->dev,
+						"exit partial_power_down failed\n");
+				call_gadget(hsotg, resume);
+			}
 
-			/* Change to L0 state */
-			hsotg->lx_state = DWC2_L0;
-			call_gadget(hsotg, resume);
+			/* Exit gadget mode clock gating. */
+			if (hsotg->params.power_down ==
+			    DWC2_POWER_DOWN_PARAM_NONE && hsotg->bus_suspended)
+				dwc2_gadget_exit_clock_gating(hsotg, 0);
 		} else {
 			/* Change to L0 state */
 			hsotg->lx_state = DWC2_L0;
 		}
 	} else {
-		if (hsotg->params.power_down)
-			return;
-
-		if (hsotg->lx_state != DWC2_L1) {
-			u32 pcgcctl = dwc2_readl(hsotg, PCGCTL);
+		if (hsotg->lx_state == DWC2_L2) {
+			if (hsotg->in_ppd) {
+				ret = dwc2_exit_partial_power_down(hsotg, 1,
+								   true);
+				if (ret)
+					dev_err(hsotg->dev,
+						"exit partial_power_down failed\n");
+			}
 
-			/* Restart the Phy Clock */
-			pcgcctl &= ~PCGCTL_STOPPCLK;
-			dwc2_writel(hsotg, pcgcctl, PCGCTL);
+			if (hsotg->params.power_down ==
+			    DWC2_POWER_DOWN_PARAM_NONE && hsotg->bus_suspended)
+				dwc2_host_exit_clock_gating(hsotg, 1);
 
 			/*
 			 * If we've got this quirk then the PHY is stuck upon
@@ -508,31 +532,34 @@ static void dwc2_handle_usb_suspend_intr
 			return;
 		}
 		if (dsts & DSTS_SUSPSTS) {
-			if (hsotg->hw_params.power_optimized) {
+			switch (hsotg->params.power_down) {
+			case DWC2_POWER_DOWN_PARAM_PARTIAL:
 				ret = dwc2_enter_partial_power_down(hsotg);
-				if (ret) {
-					if (ret != -ENOTSUPP)
-						dev_err(hsotg->dev,
-							"%s: enter partial_power_down failed\n",
-							__func__);
-					goto skip_power_saving;
-				}
+				if (ret)
+					dev_err(hsotg->dev,
+						"enter partial_power_down failed\n");
 
 				udelay(100);
 
 				/* Ask phy to be suspended */
 				if (!IS_ERR_OR_NULL(hsotg->uphy))
 					usb_phy_set_suspend(hsotg->uphy, true);
-			}
-
-			if (hsotg->hw_params.hibernation) {
+				break;
+			case DWC2_POWER_DOWN_PARAM_HIBERNATION:
 				ret = dwc2_enter_hibernation(hsotg, 0);
-				if (ret && ret != -ENOTSUPP)
+				if (ret)
 					dev_err(hsotg->dev,
-						"%s: enter hibernation failed\n",
-						__func__);
+						"enter hibernation failed\n");
+				break;
+			case DWC2_POWER_DOWN_PARAM_NONE:
+				/*
+				 * If neither hibernation nor partial power down are supported,
+				 * clock gating is used to save power.
+				 */
+				dwc2_gadget_enter_clock_gating(hsotg);
+				break;
 			}
-skip_power_saving:
+
 			/*
 			 * Change to L2 (suspend) state before releasing
 			 * spinlock
@@ -652,16 +679,82 @@ static u32 dwc2_read_common_intr(struct
 		return 0;
 }
 
+/**
+ * dwc_handle_gpwrdn_disc_det() - Handles the gpwrdn disconnect detect.
+ * Exits hibernation without restoring registers.
+ *
+ * @hsotg: Programming view of DWC_otg controller
+ * @gpwrdn: GPWRDN register
+ */
+static inline void dwc_handle_gpwrdn_disc_det(struct dwc2_hsotg *hsotg,
+					      u32 gpwrdn)
+{
+	u32 gpwrdn_tmp;
+
+	/* Switch-on voltage to the core */
+	gpwrdn_tmp = dwc2_readl(hsotg, GPWRDN);
+	gpwrdn_tmp &= ~GPWRDN_PWRDNSWTCH;
+	dwc2_writel(hsotg, gpwrdn_tmp, GPWRDN);
+	udelay(5);
+
+	/* Reset core */
+	gpwrdn_tmp = dwc2_readl(hsotg, GPWRDN);
+	gpwrdn_tmp &= ~GPWRDN_PWRDNRSTN;
+	dwc2_writel(hsotg, gpwrdn_tmp, GPWRDN);
+	udelay(5);
+
+	/* Disable Power Down Clamp */
+	gpwrdn_tmp = dwc2_readl(hsotg, GPWRDN);
+	gpwrdn_tmp &= ~GPWRDN_PWRDNCLMP;
+	dwc2_writel(hsotg, gpwrdn_tmp, GPWRDN);
+	udelay(5);
+
+	/* Deassert reset core */
+	gpwrdn_tmp = dwc2_readl(hsotg, GPWRDN);
+	gpwrdn_tmp |= GPWRDN_PWRDNRSTN;
+	dwc2_writel(hsotg, gpwrdn_tmp, GPWRDN);
+	udelay(5);
+
+	/* Disable PMU interrupt */
+	gpwrdn_tmp = dwc2_readl(hsotg, GPWRDN);
+	gpwrdn_tmp &= ~GPWRDN_PMUINTSEL;
+	dwc2_writel(hsotg, gpwrdn_tmp, GPWRDN);
+
+	/* De-assert Wakeup Logic */
+	gpwrdn_tmp = dwc2_readl(hsotg, GPWRDN);
+	gpwrdn_tmp &= ~GPWRDN_PMUACTV;
+	dwc2_writel(hsotg, gpwrdn_tmp, GPWRDN);
+
+	hsotg->hibernated = 0;
+	hsotg->bus_suspended = 0;
+
+	if (gpwrdn & GPWRDN_IDSTS) {
+		hsotg->op_state = OTG_STATE_B_PERIPHERAL;
+		dwc2_core_init(hsotg, false);
+		dwc2_enable_global_interrupts(hsotg);
+		dwc2_hsotg_core_init_disconnected(hsotg, false);
+		dwc2_hsotg_core_connect(hsotg);
+	} else {
+		hsotg->op_state = OTG_STATE_A_HOST;
+
+		/* Initialize the Core for Host mode */
+		dwc2_core_init(hsotg, false);
+		dwc2_enable_global_interrupts(hsotg);
+		dwc2_hcd_start(hsotg);
+	}
+}
+
 /*
  * GPWRDN interrupt handler.
  *
  * The GPWRDN interrupts are those that occur in both Host and
  * Device mode while core is in hibernated state.
  */
-static void dwc2_handle_gpwrdn_intr(struct dwc2_hsotg *hsotg)
+static int dwc2_handle_gpwrdn_intr(struct dwc2_hsotg *hsotg)
 {
 	u32 gpwrdn;
 	int linestate;
+	int ret = 0;
 
 	gpwrdn = dwc2_readl(hsotg, GPWRDN);
 	/* clear all interrupt */
@@ -673,93 +766,52 @@ static void dwc2_handle_gpwrdn_intr(stru
 
 	if ((gpwrdn & GPWRDN_DISCONN_DET) &&
 	    (gpwrdn & GPWRDN_DISCONN_DET_MSK) && !linestate) {
-		u32 gpwrdn_tmp;
-
 		dev_dbg(hsotg->dev, "%s: GPWRDN_DISCONN_DET\n", __func__);
-
-		/* Switch-on voltage to the core */
-		gpwrdn_tmp = dwc2_readl(hsotg, GPWRDN);
-		gpwrdn_tmp &= ~GPWRDN_PWRDNSWTCH;
-		dwc2_writel(hsotg, gpwrdn_tmp, GPWRDN);
-		udelay(10);
-
-		/* Reset core */
-		gpwrdn_tmp = dwc2_readl(hsotg, GPWRDN);
-		gpwrdn_tmp &= ~GPWRDN_PWRDNRSTN;
-		dwc2_writel(hsotg, gpwrdn_tmp, GPWRDN);
-		udelay(10);
-
-		/* Disable Power Down Clamp */
-		gpwrdn_tmp = dwc2_readl(hsotg, GPWRDN);
-		gpwrdn_tmp &= ~GPWRDN_PWRDNCLMP;
-		dwc2_writel(hsotg, gpwrdn_tmp, GPWRDN);
-		udelay(10);
-
-		/* Deassert reset core */
-		gpwrdn_tmp = dwc2_readl(hsotg, GPWRDN);
-		gpwrdn_tmp |= GPWRDN_PWRDNRSTN;
-		dwc2_writel(hsotg, gpwrdn_tmp, GPWRDN);
-		udelay(10);
-
-		/* Disable PMU interrupt */
-		gpwrdn_tmp = dwc2_readl(hsotg, GPWRDN);
-		gpwrdn_tmp &= ~GPWRDN_PMUINTSEL;
-		dwc2_writel(hsotg, gpwrdn_tmp, GPWRDN);
-
-		/* De-assert Wakeup Logic */
-		gpwrdn_tmp = dwc2_readl(hsotg, GPWRDN);
-		gpwrdn_tmp &= ~GPWRDN_PMUACTV;
-		dwc2_writel(hsotg, gpwrdn_tmp, GPWRDN);
-
-		hsotg->hibernated = 0;
-
-		if (gpwrdn & GPWRDN_IDSTS) {
-			hsotg->op_state = OTG_STATE_B_PERIPHERAL;
-			dwc2_core_init(hsotg, false);
-			dwc2_enable_global_interrupts(hsotg);
-			dwc2_hsotg_core_init_disconnected(hsotg, false);
-			dwc2_hsotg_core_connect(hsotg);
-		} else {
-			hsotg->op_state = OTG_STATE_A_HOST;
-
-			/* Initialize the Core for Host mode */
-			dwc2_core_init(hsotg, false);
-			dwc2_enable_global_interrupts(hsotg);
-			dwc2_hcd_start(hsotg);
-		}
-	}
-
-	if ((gpwrdn & GPWRDN_LNSTSCHG) &&
-	    (gpwrdn & GPWRDN_LNSTSCHG_MSK) && linestate) {
+		/*
+		 * Call disconnect detect function to exit from
+		 * hibernation
+		 */
+		dwc_handle_gpwrdn_disc_det(hsotg, gpwrdn);
+	} else if ((gpwrdn & GPWRDN_LNSTSCHG) &&
+		   (gpwrdn & GPWRDN_LNSTSCHG_MSK) && linestate) {
 		dev_dbg(hsotg->dev, "%s: GPWRDN_LNSTSCHG\n", __func__);
 		if (hsotg->hw_params.hibernation &&
 		    hsotg->hibernated) {
 			if (gpwrdn & GPWRDN_IDSTS) {
-				dwc2_exit_hibernation(hsotg, 0, 0, 0);
+				ret = dwc2_exit_hibernation(hsotg, 0, 0, 0);
+				if (ret)
+					dev_err(hsotg->dev,
+						"exit hibernation failed.\n");
 				call_gadget(hsotg, resume);
 			} else {
-				dwc2_exit_hibernation(hsotg, 1, 0, 1);
+				ret = dwc2_exit_hibernation(hsotg, 1, 0, 1);
+				if (ret)
+					dev_err(hsotg->dev,
+						"exit hibernation failed.\n");
 			}
 		}
-	}
-	if ((gpwrdn & GPWRDN_RST_DET) && (gpwrdn & GPWRDN_RST_DET_MSK)) {
+	} else if ((gpwrdn & GPWRDN_RST_DET) &&
+		   (gpwrdn & GPWRDN_RST_DET_MSK)) {
 		dev_dbg(hsotg->dev, "%s: GPWRDN_RST_DET\n", __func__);
-		if (!linestate && (gpwrdn & GPWRDN_BSESSVLD))
-			dwc2_exit_hibernation(hsotg, 0, 1, 0);
-	}
-	if ((gpwrdn & GPWRDN_STS_CHGINT) &&
-	    (gpwrdn & GPWRDN_STS_CHGINT_MSK) && linestate) {
-		dev_dbg(hsotg->dev, "%s: GPWRDN_STS_CHGINT\n", __func__);
-		if (hsotg->hw_params.hibernation &&
-		    hsotg->hibernated) {
-			if (gpwrdn & GPWRDN_IDSTS) {
-				dwc2_exit_hibernation(hsotg, 0, 0, 0);
-				call_gadget(hsotg, resume);
-			} else {
-				dwc2_exit_hibernation(hsotg, 1, 0, 1);
-			}
+		if (!linestate) {
+			ret = dwc2_exit_hibernation(hsotg, 0, 1, 0);
+			if (ret)
+				dev_err(hsotg->dev,
+					"exit hibernation failed.\n");
 		}
+	} else if ((gpwrdn & GPWRDN_STS_CHGINT) &&
+		   (gpwrdn & GPWRDN_STS_CHGINT_MSK)) {
+		dev_dbg(hsotg->dev, "%s: GPWRDN_STS_CHGINT\n", __func__);
+		/*
+		 * As GPWRDN_STS_CHGINT exit from hibernation flow is
+		 * the same as in GPWRDN_DISCONN_DET flow. Call
+		 * disconnect detect helper function to exit from
+		 * hibernation.
+		 */
+		dwc_handle_gpwrdn_disc_det(hsotg, gpwrdn);
 	}
+
+	return ret;
 }
 
 /*
diff -urpN --no-dereference -X diffgen.ignore test-tree/drivers/usb/dwc2/debugfs.c milky/drivers/usb/dwc2/debugfs.c
--- test-tree/drivers/usb/dwc2/debugfs.c	2024-06-01 13:18:41.872500285 -0400
+++ milky/drivers/usb/dwc2/debugfs.c	2024-05-21 05:22:27.000000000 -0400
@@ -691,6 +691,8 @@ static int params_show(struct seq_file *
 	print_param(seq, p, ulpi_fs_ls);
 	print_param(seq, p, host_support_fs_ls_low_power);
 	print_param(seq, p, host_ls_low_power_phy_clk);
+	print_param(seq, p, activate_stm_fs_transceiver);
+	print_param(seq, p, activate_stm_id_vb_detection);
 	print_param(seq, p, ts_dline);
 	print_param(seq, p, reload_ctl);
 	print_param_hex(seq, p, ahbcfg);
diff -urpN --no-dereference -X diffgen.ignore test-tree/drivers/usb/dwc2/gadget.c milky/drivers/usb/dwc2/gadget.c
--- test-tree/drivers/usb/dwc2/gadget.c	2024-06-01 13:18:41.876500271 -0400
+++ milky/drivers/usb/dwc2/gadget.c	2024-05-21 05:22:27.000000000 -0400
@@ -304,7 +304,12 @@ static void dwc2_hsotg_init_fifo(struct
 	u32 *txfsz = hsotg->params.g_tx_fifo_size;
 
 	/* Reset fifo map if not correctly cleared during previous session */
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	dev_dbg(hsotg->dev,
+		"%s: fifo is not cleared correctly\n", __func__);
+#else
 	WARN_ON(hsotg->fifo_map);
+#endif
 	hsotg->fifo_map = 0;
 
 	/* set RX/NPTX FIFO sizes */
@@ -422,7 +427,10 @@ static void dwc2_hsotg_unmap_dma(struct
 {
 	struct usb_request *req = &hs_req->req;
 
-	usb_gadget_unmap_request(&hsotg->gadget, req, hs_ep->dir_in);
+	usb_gadget_unmap_request(&hsotg->gadget, req, hs_ep->map_dir);
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	req->dma = 0;
+#endif
 }
 
 /*
@@ -1242,6 +1250,11 @@ static int dwc2_hsotg_map_dma(struct dwc
 {
 	int ret;
 
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	if (req->dma)
+		return 0;
+#endif
+	hs_ep->map_dir = hs_ep->dir_in;
 	ret = usb_gadget_map_request(&hsotg->gadget, req, hs_ep->dir_in);
 	if (ret)
 		goto dma_error;
@@ -1543,7 +1556,6 @@ static void dwc2_hsotg_complete_oursetup
 static struct dwc2_hsotg_ep *ep_from_windex(struct dwc2_hsotg *hsotg,
 					    u32 windex)
 {
-	struct dwc2_hsotg_ep *ep;
 	int dir = (windex & USB_DIR_IN) ? 1 : 0;
 	int idx = windex & 0x7F;
 
@@ -1553,12 +1565,7 @@ static struct dwc2_hsotg_ep *ep_from_win
 	if (idx > hsotg->num_of_eps)
 		return NULL;
 
-	ep = index_to_ep(hsotg, idx, dir);
-
-	if (idx && ep->dir_in != dir)
-		return NULL;
-
-	return ep;
+	return index_to_ep(hsotg, idx, dir);
 }
 
 /**
@@ -2036,7 +2043,15 @@ static void dwc2_hsotg_enqueue_setup(str
 
 	ret = dwc2_hsotg_ep_queue(&hsotg->eps_out[0]->ep, req, GFP_ATOMIC);
 	if (ret < 0) {
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+		/* Not to show this message due to flow necessary.
+		 * We may switch to device mode without cable connected.
+		 */
+		if (ret != -EAGAIN)
+			dev_err(hsotg->dev, "%s: failed queue (%d)\n", __func__, ret);
+#else
 		dev_err(hsotg->dev, "%s: failed queue (%d)\n", __func__, ret);
+#endif
 		/*
 		 * Don't think there's much we can do other than watch the
 		 * driver fail.
@@ -3386,7 +3401,7 @@ void dwc2_hsotg_core_init_disconnected(s
 
 	/* remove the HNP/SRP and set the PHY */
 	usbcfg &= ~(GUSBCFG_SRPCAP | GUSBCFG_HNPCAP);
-        dwc2_writel(hsotg, usbcfg, GUSBCFG);
+	dwc2_writel(hsotg, usbcfg, GUSBCFG);
 
 	dwc2_phy_init(hsotg, true);
 
@@ -3695,10 +3710,10 @@ irq_retry:
 		dwc2_writel(hsotg, GINTSTS_RESETDET, GINTSTS);
 
 		/* This event must be used only if controller is suspended */
-		if (hsotg->lx_state == DWC2_L2) {
-			dwc2_exit_partial_power_down(hsotg, true);
-			hsotg->lx_state = DWC2_L0;
-		}
+		if (hsotg->in_ppd && hsotg->lx_state == DWC2_L2)
+			dwc2_exit_partial_power_down(hsotg, 0, true);
+
+		hsotg->lx_state = DWC2_L0;
 	}
 
 	if (gintsts & (GINTSTS_USBRST | GINTSTS_RESETDET)) {
@@ -4621,11 +4636,15 @@ static int dwc2_hsotg_vbus_session(struc
 	spin_lock_irqsave(&hsotg->lock, flags);
 
 	/*
-	 * If controller is hibernated, it must exit from power_down
-	 * before being initialized / de-initialized
+	 * If controller is in partial power down state, it must exit from
+	 * that state before being initialized / de-initialized
 	 */
-	if (hsotg->lx_state == DWC2_L2)
-		dwc2_exit_partial_power_down(hsotg, false);
+	if (hsotg->lx_state == DWC2_L2 && hsotg->in_ppd)
+		/*
+		 * No need to check the return value as
+		 * registers are not being restored.
+		 */
+		dwc2_exit_partial_power_down(hsotg, 0, false);
 
 	if (is_active) {
 		hsotg->op_state = OTG_STATE_B_PERIPHERAL;
@@ -4884,6 +4903,10 @@ int dwc2_gadget_init(struct dwc2_hsotg *
 	else if (hsotg->dr_mode == USB_DR_MODE_PERIPHERAL)
 		hsotg->op_state = OTG_STATE_B_PERIPHERAL;
 
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	/* Not support OTG protocol */
+	hsotg->gadget.is_otg = 0;
+#endif
 	ret = dwc2_hsotg_hw_cfg(hsotg);
 	if (ret) {
 		dev_err(hsotg->dev, "Hardware configuration failed: %d\n", ret);
@@ -5307,6 +5330,10 @@ int dwc2_gadget_exit_hibernation(struct
 	dwc2_writel(hsotg, dr->dcfg, DCFG);
 	dwc2_writel(hsotg, dr->dctl, DCTL);
 
+	/* On USB Reset, reset device address to zero */
+	if (reset)
+		dwc2_clear_bit(hsotg, DCFG, DCFG_DEVADDR_MASK);
+
 	/* De-assert Wakeup Logic */
 	gpwrdn = dwc2_readl(hsotg, GPWRDN);
 	gpwrdn &= ~GPWRDN_PMUACTV;
@@ -5357,3 +5384,205 @@ int dwc2_gadget_exit_hibernation(struct
 
 	return ret;
 }
+
+/**
+ * dwc2_gadget_enter_partial_power_down() - Put controller in partial
+ * power down.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ *
+ * Return: non-zero if failed to enter device partial power down.
+ *
+ * This function is for entering device mode partial power down.
+ */
+int dwc2_gadget_enter_partial_power_down(struct dwc2_hsotg *hsotg)
+{
+	u32 pcgcctl;
+	int ret = 0;
+
+	dev_dbg(hsotg->dev, "Entering device partial power down started.\n");
+
+	/* Backup all registers */
+	ret = dwc2_backup_global_registers(hsotg);
+	if (ret) {
+		dev_err(hsotg->dev, "%s: failed to backup global registers\n",
+			__func__);
+		return ret;
+	}
+
+	ret = dwc2_backup_device_registers(hsotg);
+	if (ret) {
+		dev_err(hsotg->dev, "%s: failed to backup device registers\n",
+			__func__);
+		return ret;
+	}
+
+	/*
+	 * Clear any pending interrupts since dwc2 will not be able to
+	 * clear them after entering partial_power_down.
+	 */
+	dwc2_writel(hsotg, 0xffffffff, GINTSTS);
+
+	/* Put the controller in low power state */
+	pcgcctl = dwc2_readl(hsotg, PCGCTL);
+
+	pcgcctl |= PCGCTL_PWRCLMP;
+	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+	udelay(5);
+
+	pcgcctl |= PCGCTL_RSTPDWNMODULE;
+	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+	udelay(5);
+
+	pcgcctl |= PCGCTL_STOPPCLK;
+	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+
+	/* Set in_ppd flag to 1 as here core enters suspend. */
+	hsotg->in_ppd = 1;
+	hsotg->lx_state = DWC2_L2;
+
+	dev_dbg(hsotg->dev, "Entering device partial power down completed.\n");
+
+	return ret;
+}
+
+/*
+ * dwc2_gadget_exit_partial_power_down() - Exit controller from device partial
+ * power down.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ * @restore: indicates whether need to restore the registers or not.
+ *
+ * Return: non-zero if failed to exit device partial power down.
+ *
+ * This function is for exiting from device mode partial power down.
+ */
+int dwc2_gadget_exit_partial_power_down(struct dwc2_hsotg *hsotg,
+					bool restore)
+{
+	u32 pcgcctl;
+	u32 dctl;
+	struct dwc2_dregs_backup *dr;
+	int ret = 0;
+
+	dr = &hsotg->dr_backup;
+
+	dev_dbg(hsotg->dev, "Exiting device partial Power Down started.\n");
+
+	pcgcctl = dwc2_readl(hsotg, PCGCTL);
+	pcgcctl &= ~PCGCTL_STOPPCLK;
+	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+
+	pcgcctl = dwc2_readl(hsotg, PCGCTL);
+	pcgcctl &= ~PCGCTL_PWRCLMP;
+	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+
+	pcgcctl = dwc2_readl(hsotg, PCGCTL);
+	pcgcctl &= ~PCGCTL_RSTPDWNMODULE;
+	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+
+	udelay(100);
+	if (restore) {
+		ret = dwc2_restore_global_registers(hsotg);
+		if (ret) {
+			dev_err(hsotg->dev, "%s: failed to restore registers\n",
+				__func__);
+			return ret;
+		}
+		/* Restore DCFG */
+		dwc2_writel(hsotg, dr->dcfg, DCFG);
+
+		ret = dwc2_restore_device_registers(hsotg, 0);
+		if (ret) {
+			dev_err(hsotg->dev, "%s: failed to restore device registers\n",
+				__func__);
+			return ret;
+		}
+	}
+
+	/* Set the Power-On Programming done bit */
+	dctl = dwc2_readl(hsotg, DCTL);
+	dctl |= DCTL_PWRONPRGDONE;
+	dwc2_writel(hsotg, dctl, DCTL);
+
+	/* Set in_ppd flag to 0 as here core exits from suspend. */
+	hsotg->in_ppd = 0;
+	hsotg->lx_state = DWC2_L0;
+
+	dev_dbg(hsotg->dev, "Exiting device partial Power Down completed.\n");
+	return ret;
+}
+
+/**
+ * dwc2_gadget_enter_clock_gating() - Put controller in clock gating.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ *
+ * Return: non-zero if failed to enter device partial power down.
+ *
+ * This function is for entering device mode clock gating.
+ */
+void dwc2_gadget_enter_clock_gating(struct dwc2_hsotg *hsotg)
+{
+	u32 pcgctl;
+
+	dev_dbg(hsotg->dev, "Entering device clock gating.\n");
+
+	/* Set the Phy Clock bit as suspend is received. */
+	pcgctl = dwc2_readl(hsotg, PCGCTL);
+	pcgctl |= PCGCTL_STOPPCLK;
+	dwc2_writel(hsotg, pcgctl, PCGCTL);
+	udelay(5);
+#if !IS_ENABLED(CONFIG_ARCH_CVITEK)
+	/* Set the Gate hclk as suspend is received. */
+	pcgctl = dwc2_readl(hsotg, PCGCTL);
+	pcgctl |= PCGCTL_GATEHCLK;
+	dwc2_writel(hsotg, pcgctl, PCGCTL);
+	udelay(5);
+#endif
+
+	hsotg->lx_state = DWC2_L2;
+	hsotg->bus_suspended = true;
+}
+
+/*
+ * dwc2_gadget_exit_clock_gating() - Exit controller from device clock gating.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ * @rem_wakeup: indicates whether remote wake up is enabled.
+ *
+ * This function is for exiting from device mode clock gating.
+ */
+void dwc2_gadget_exit_clock_gating(struct dwc2_hsotg *hsotg, int rem_wakeup)
+{
+	u32 pcgctl;
+	u32 dctl;
+
+	dev_dbg(hsotg->dev, "Exiting device clock gating.\n");
+
+#if !IS_ENABLED(CONFIG_ARCH_CVITEK)
+	/* Clear the Gate hclk. */
+	pcgctl = dwc2_readl(hsotg, PCGCTL);
+	pcgctl &= ~PCGCTL_GATEHCLK;
+	dwc2_writel(hsotg, pcgctl, PCGCTL);
+	udelay(5);
+#endif
+
+	/* Phy Clock bit. */
+	pcgctl = dwc2_readl(hsotg, PCGCTL);
+	pcgctl &= ~PCGCTL_STOPPCLK;
+	dwc2_writel(hsotg, pcgctl, PCGCTL);
+	udelay(5);
+
+	if (rem_wakeup) {
+		/* Set Remote Wakeup Signaling */
+		dctl = dwc2_readl(hsotg, DCTL);
+		dctl |= DCTL_RMTWKUPSIG;
+		dwc2_writel(hsotg, dctl, DCTL);
+	}
+
+	/* Change to L0 state */
+	call_gadget(hsotg, resume);
+	hsotg->lx_state = DWC2_L0;
+	hsotg->bus_suspended = false;
+}
diff -urpN --no-dereference -X diffgen.ignore test-tree/drivers/usb/dwc2/hcd.c milky/drivers/usb/dwc2/hcd.c
--- test-tree/drivers/usb/dwc2/hcd.c	2024-06-01 13:18:41.876500271 -0400
+++ milky/drivers/usb/dwc2/hcd.c	2024-05-21 05:22:27.000000000 -0400
@@ -56,8 +56,6 @@
 #include "core.h"
 #include "hcd.h"
 
-static void dwc2_port_resume(struct dwc2_hsotg *hsotg);
-
 /*
  * =========================================================================
  *  Host Core Layer Functions
@@ -1313,19 +1311,20 @@ static void dwc2_hc_start_transfer(struc
 			if (num_packets > max_hc_pkt_count) {
 				num_packets = max_hc_pkt_count;
 				chan->xfer_len = num_packets * chan->max_packet;
+			} else if (chan->ep_is_in) {
+				/*
+				 * Always program an integral # of max packets
+				 * for IN transfers.
+				 * Note: This assumes that the input buffer is
+				 * aligned and sized accordingly.
+				 */
+				chan->xfer_len = num_packets * chan->max_packet;
 			}
 		} else {
 			/* Need 1 packet for transfer length of 0 */
 			num_packets = 1;
 		}
 
-		if (chan->ep_is_in)
-			/*
-			 * Always program an integral # of max packets for IN
-			 * transfers
-			 */
-			chan->xfer_len = num_packets * chan->max_packet;
-
 		if (chan->ep_type == USB_ENDPOINT_XFER_INT ||
 		    chan->ep_type == USB_ENDPOINT_XFER_ISOC)
 			/*
@@ -3207,6 +3206,15 @@ static void dwc2_conn_id_status_change(s
 		if (count > 250)
 			dev_err(hsotg->dev,
 				"Connection id status change timed out\n");
+
+		/*
+		 * Exit Partial Power Down without restoring registers.
+		 * No need to check the return value as registers
+		 * are not being restored.
+		 */
+		if (hsotg->in_ppd && hsotg->lx_state == DWC2_L2)
+			dwc2_exit_partial_power_down(hsotg, 0, false);
+
 		hsotg->op_state = OTG_STATE_B_PERIPHERAL;
 		dwc2_core_init(hsotg, false);
 		dwc2_enable_global_interrupts(hsotg);
@@ -3276,13 +3284,23 @@ static int dwc2_host_is_b_hnp_enabled(st
 	return hcd->self.b_hnp_enable;
 }
 
-/* Must NOT be called with interrupt disabled or spinlock held */
-static void dwc2_port_suspend(struct dwc2_hsotg *hsotg, u16 windex)
+/**
+ * dwc2_port_suspend() - Put controller in suspend mode for host.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ * @windex: The control request wIndex field
+ *
+ * Return: non-zero if failed to enter suspend mode for host.
+ *
+ * This function is for entering Host mode suspend.
+ * Must NOT be called with interrupt disabled or spinlock held.
+ */
+int dwc2_port_suspend(struct dwc2_hsotg *hsotg, u16 windex)
 {
 	unsigned long flags;
-	u32 hprt0;
 	u32 pcgctl;
 	u32 gotgctl;
+	int ret = 0;
 
 	dev_dbg(hsotg->dev, "%s()\n", __func__);
 
@@ -3295,22 +3313,33 @@ static void dwc2_port_suspend(struct dwc
 		hsotg->op_state = OTG_STATE_A_SUSPEND;
 	}
 
-	hprt0 = dwc2_read_hprt0(hsotg);
-	hprt0 |= HPRT0_SUSP;
-	dwc2_writel(hsotg, hprt0, HPRT0);
-
-	hsotg->bus_suspended = true;
-
-	/*
-	 * If power_down is supported, Phy clock will be suspended
-	 * after registers are backuped.
-	 */
-	if (!hsotg->params.power_down) {
-		/* Suspend the Phy Clock */
-		pcgctl = dwc2_readl(hsotg, PCGCTL);
-		pcgctl |= PCGCTL_STOPPCLK;
-		dwc2_writel(hsotg, pcgctl, PCGCTL);
-		udelay(10);
+	switch (hsotg->params.power_down) {
+	case DWC2_POWER_DOWN_PARAM_PARTIAL:
+		ret = dwc2_enter_partial_power_down(hsotg);
+		if (ret)
+			dev_err(hsotg->dev,
+				"enter partial_power_down failed.\n");
+		break;
+	case DWC2_POWER_DOWN_PARAM_HIBERNATION:
+		/*
+		 * Perform spin unlock and lock because in
+		 * "dwc2_host_enter_hibernation()" function there is a spinlock
+		 * logic which prevents servicing of any IRQ during entering
+		 * hibernation.
+		 */
+		spin_unlock_irqrestore(&hsotg->lock, flags);
+		ret = dwc2_enter_hibernation(hsotg, 1);
+		if (ret)
+			dev_err(hsotg->dev, "enter hibernation failed.\n");
+		spin_lock_irqsave(&hsotg->lock, flags);
+		break;
+	case DWC2_POWER_DOWN_PARAM_NONE:
+		/*
+		 * If not hibernation nor partial power down are supported,
+		 * clock gating is used to save power.
+		 */
+		dwc2_host_enter_clock_gating(hsotg);
+		break;
 	}
 
 	/* For HNP the bus must be suspended for at least 200ms */
@@ -3325,44 +3354,54 @@ static void dwc2_port_suspend(struct dwc
 	} else {
 		spin_unlock_irqrestore(&hsotg->lock, flags);
 	}
+
+	return ret;
 }
 
-/* Must NOT be called with interrupt disabled or spinlock held */
-static void dwc2_port_resume(struct dwc2_hsotg *hsotg)
+/**
+ * dwc2_port_resume() - Exit controller from suspend mode for host.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ *
+ * Return: non-zero if failed to exit suspend mode for host.
+ *
+ * This function is for exiting Host mode suspend.
+ * Must NOT be called with interrupt disabled or spinlock held.
+ */
+int dwc2_port_resume(struct dwc2_hsotg *hsotg)
 {
 	unsigned long flags;
-	u32 hprt0;
-	u32 pcgctl;
+	int ret = 0;
 
 	spin_lock_irqsave(&hsotg->lock, flags);
 
-	/*
-	 * If power_down is supported, Phy clock is already resumed
-	 * after registers restore.
-	 */
-	if (!hsotg->params.power_down) {
-		pcgctl = dwc2_readl(hsotg, PCGCTL);
-		pcgctl &= ~PCGCTL_STOPPCLK;
-		dwc2_writel(hsotg, pcgctl, PCGCTL);
+	switch (hsotg->params.power_down) {
+	case DWC2_POWER_DOWN_PARAM_PARTIAL:
+		ret = dwc2_exit_partial_power_down(hsotg, 0, true);
+		if (ret)
+			dev_err(hsotg->dev,
+				"exit partial_power_down failed.\n");
+		break;
+	case DWC2_POWER_DOWN_PARAM_HIBERNATION:
+		/* Exit host hibernation. */
+		ret = dwc2_exit_hibernation(hsotg, 0, 0, 1);
+		if (ret)
+			dev_err(hsotg->dev, "exit hibernation failed.\n");
+		break;
+	case DWC2_POWER_DOWN_PARAM_NONE:
+		/*
+		 * If not hibernation nor partial power down are supported,
+		 * port resume is done using the clock gating programming flow.
+		 */
 		spin_unlock_irqrestore(&hsotg->lock, flags);
-		msleep(20);
+		dwc2_host_exit_clock_gating(hsotg, 0);
 		spin_lock_irqsave(&hsotg->lock, flags);
+		break;
 	}
 
-	hprt0 = dwc2_read_hprt0(hsotg);
-	hprt0 |= HPRT0_RES;
-	hprt0 &= ~HPRT0_SUSP;
-	dwc2_writel(hsotg, hprt0, HPRT0);
 	spin_unlock_irqrestore(&hsotg->lock, flags);
 
-	msleep(USB_RESUME_TIMEOUT);
-
-	spin_lock_irqsave(&hsotg->lock, flags);
-	hprt0 = dwc2_read_hprt0(hsotg);
-	hprt0 &= ~(HPRT0_RES | HPRT0_SUSP);
-	dwc2_writel(hsotg, hprt0, HPRT0);
-	hsotg->bus_suspended = false;
-	spin_unlock_irqrestore(&hsotg->lock, flags);
+	return ret;
 }
 
 /* Handles hub class-specific requests */
@@ -3412,12 +3451,8 @@ static int dwc2_hcd_hub_control(struct d
 			dev_dbg(hsotg->dev,
 				"ClearPortFeature USB_PORT_FEAT_SUSPEND\n");
 
-			if (hsotg->bus_suspended) {
-				if (hsotg->hibernated)
-					dwc2_exit_hibernation(hsotg, 0, 0, 1);
-				else
-					dwc2_port_resume(hsotg);
-			}
+			if (hsotg->bus_suspended)
+				retval = dwc2_port_resume(hsotg);
 			break;
 
 		case USB_PORT_FEAT_POWER:
@@ -3628,10 +3663,8 @@ static int dwc2_hcd_hub_control(struct d
 				"SetPortFeature - USB_PORT_FEAT_SUSPEND\n");
 			if (windex != hsotg->otg_port)
 				goto error;
-			if (hsotg->params.power_down == DWC2_POWER_DOWN_PARAM_HIBERNATION)
-				dwc2_enter_hibernation(hsotg, 1);
-			else
-				dwc2_port_suspend(hsotg, windex);
+			if (!hsotg->bus_suspended)
+				retval = dwc2_port_suspend(hsotg, windex);
 			break;
 
 		case USB_PORT_FEAT_POWER:
@@ -3646,12 +3679,30 @@ static int dwc2_hcd_hub_control(struct d
 			break;
 
 		case USB_PORT_FEAT_RESET:
-			if (hsotg->params.power_down == DWC2_POWER_DOWN_PARAM_HIBERNATION &&
-			    hsotg->hibernated)
-				dwc2_exit_hibernation(hsotg, 0, 1, 1);
-			hprt0 = dwc2_read_hprt0(hsotg);
 			dev_dbg(hsotg->dev,
 				"SetPortFeature - USB_PORT_FEAT_RESET\n");
+
+			hprt0 = dwc2_read_hprt0(hsotg);
+
+			if (hsotg->hibernated) {
+				retval = dwc2_exit_hibernation(hsotg, 0, 1, 1);
+				if (retval)
+					dev_err(hsotg->dev,
+						"exit hibernation failed\n");
+			}
+
+			if (hsotg->in_ppd) {
+				retval = dwc2_exit_partial_power_down(hsotg, 1,
+								      true);
+				if (retval)
+					dev_err(hsotg->dev,
+						"exit partial_power_down failed\n");
+			}
+
+			if (hsotg->params.power_down ==
+			    DWC2_POWER_DOWN_PARAM_NONE && hsotg->bus_suspended)
+				dwc2_host_exit_clock_gating(hsotg, 0);
+
 			pcgctl = dwc2_readl(hsotg, PCGCTL);
 			pcgctl &= ~(PCGCTL_ENBL_SLEEP_GATING | PCGCTL_STOPPCLK);
 			dwc2_writel(hsotg, pcgctl, PCGCTL);
@@ -4304,8 +4355,8 @@ static int _dwc2_hcd_suspend(struct usb_
 	struct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);
 	unsigned long flags;
 	int ret = 0;
-	u32 hprt0;
-	u32 pcgctl;
+
+	dev_dbg(hsotg->dev, "DWC OTG HCD SUSPEND\n");
 
 	spin_lock_irqsave(&hsotg->lock, flags);
 
@@ -4321,46 +4372,51 @@ static int _dwc2_hcd_suspend(struct usb_
 	if (hsotg->op_state == OTG_STATE_B_PERIPHERAL)
 		goto unlock;
 
-	if (hsotg->params.power_down > DWC2_POWER_DOWN_PARAM_PARTIAL)
+	if (hsotg->bus_suspended)
 		goto skip_power_saving;
 
-	/*
-	 * Drive USB suspend and disable port Power
-	 * if usb bus is not suspended.
-	 */
-	if (!hsotg->bus_suspended) {
-		hprt0 = dwc2_read_hprt0(hsotg);
-		if (hprt0 & HPRT0_CONNSTS) {
-			hprt0 |= HPRT0_SUSP;
-			if (hsotg->params.power_down == DWC2_POWER_DOWN_PARAM_PARTIAL)
-				hprt0 &= ~HPRT0_PWR;
-			dwc2_writel(hsotg, hprt0, HPRT0);
-		}
-		if (hsotg->params.power_down == DWC2_POWER_DOWN_PARAM_PARTIAL) {
-			spin_unlock_irqrestore(&hsotg->lock, flags);
-			dwc2_vbus_supply_exit(hsotg);
-			spin_lock_irqsave(&hsotg->lock, flags);
-		} else {
-			pcgctl = readl(hsotg->regs + PCGCTL);
-			pcgctl |= PCGCTL_STOPPCLK;
-			writel(pcgctl, hsotg->regs + PCGCTL);
-		}
-	}
+	if (hsotg->flags.b.port_connect_status == 0)
+		goto skip_power_saving;
 
-	if (hsotg->params.power_down == DWC2_POWER_DOWN_PARAM_PARTIAL) {
+	switch (hsotg->params.power_down) {
+	case DWC2_POWER_DOWN_PARAM_PARTIAL:
 		/* Enter partial_power_down */
 		ret = dwc2_enter_partial_power_down(hsotg);
-		if (ret) {
-			if (ret != -ENOTSUPP)
-				dev_err(hsotg->dev,
-					"enter partial_power_down failed\n");
-			goto skip_power_saving;
-		}
+		if (ret)
+			dev_err(hsotg->dev,
+				"enter partial_power_down failed\n");
+		/* After entering suspend, hardware is not accessible */
+		clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+		break;
+	case DWC2_POWER_DOWN_PARAM_HIBERNATION:
+		/* Enter hibernation */
+		spin_unlock_irqrestore(&hsotg->lock, flags);
+		ret = dwc2_enter_hibernation(hsotg, 1);
+		if (ret)
+			dev_err(hsotg->dev, "enter hibernation failed\n");
+		spin_lock_irqsave(&hsotg->lock, flags);
 
-		/* After entering partial_power_down, hardware is no more accessible */
+		/* After entering suspend, hardware is not accessible */
 		clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+		break;
+	case DWC2_POWER_DOWN_PARAM_NONE:
+		/*
+		 * If not hibernation nor partial power down are supported,
+		 * clock gating is used to save power.
+		 */
+		dwc2_host_enter_clock_gating(hsotg);
+
+		/* After entering suspend, hardware is not accessible */
+		clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+		break;
+	default:
+		goto skip_power_saving;
 	}
 
+	spin_unlock_irqrestore(&hsotg->lock, flags);
+	dwc2_vbus_supply_exit(hsotg);
+	spin_lock_irqsave(&hsotg->lock, flags);
+
 	/* Ask phy to be suspended */
 	if (!IS_ERR_OR_NULL(hsotg->uphy)) {
 		spin_unlock_irqrestore(&hsotg->lock, flags);
@@ -4380,9 +4436,11 @@ static int _dwc2_hcd_resume(struct usb_h
 {
 	struct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);
 	unsigned long flags;
-	u32 pcgctl;
+	u32 hprt0;
 	int ret = 0;
 
+	dev_dbg(hsotg->dev, "DWC OTG HCD RESUME\n");
+
 	spin_lock_irqsave(&hsotg->lock, flags);
 
 	if (dwc2_is_device_mode(hsotg))
@@ -4391,68 +4449,102 @@ static int _dwc2_hcd_resume(struct usb_h
 	if (hsotg->lx_state != DWC2_L2)
 		goto unlock;
 
-	if (hsotg->params.power_down > DWC2_POWER_DOWN_PARAM_PARTIAL) {
+	hprt0 = dwc2_read_hprt0(hsotg);
+
+	/*
+	 * Added port connection status checking which prevents exiting from
+	 * Partial Power Down mode from _dwc2_hcd_resume() if not in Partial
+	 * Power Down mode.
+	 */
+	if (hprt0 & HPRT0_CONNSTS) {
 		hsotg->lx_state = DWC2_L0;
 		goto unlock;
 	}
 
-	/*
-	 * Enable power if not already done.
-	 * This must not be spinlocked since duration
-	 * of this call is unknown.
-	 */
-	if (!IS_ERR_OR_NULL(hsotg->uphy)) {
+	switch (hsotg->params.power_down) {
+	case DWC2_POWER_DOWN_PARAM_PARTIAL:
+		ret = dwc2_exit_partial_power_down(hsotg, 0, true);
+		if (ret)
+			dev_err(hsotg->dev,
+				"exit partial_power_down failed\n");
+		/*
+		 * Set HW accessible bit before powering on the controller
+		 * since an interrupt may rise.
+		 */
+		set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+		break;
+	case DWC2_POWER_DOWN_PARAM_HIBERNATION:
+		ret = dwc2_exit_hibernation(hsotg, 0, 0, 1);
+		if (ret)
+			dev_err(hsotg->dev, "exit hibernation failed.\n");
+
+		/*
+		 * Set HW accessible bit before powering on the controller
+		 * since an interrupt may rise.
+		 */
+		set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+		break;
+	case DWC2_POWER_DOWN_PARAM_NONE:
+		/*
+		 * If not hibernation nor partial power down are supported,
+		 * port resume is done using the clock gating programming flow.
+		 */
 		spin_unlock_irqrestore(&hsotg->lock, flags);
-		usb_phy_set_suspend(hsotg->uphy, false);
+		dwc2_host_exit_clock_gating(hsotg, 0);
+
+		/*
+		 * Initialize the Core for Host mode, as after system resume
+		 * the global interrupts are disabled.
+		 */
+		dwc2_core_init(hsotg, false);
+		dwc2_enable_global_interrupts(hsotg);
+		dwc2_hcd_reinit(hsotg);
 		spin_lock_irqsave(&hsotg->lock, flags);
-	}
 
-	if (hsotg->params.power_down == DWC2_POWER_DOWN_PARAM_PARTIAL) {
 		/*
 		 * Set HW accessible bit before powering on the controller
 		 * since an interrupt may rise.
 		 */
 		set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+		break;
+	default:
+		hsotg->lx_state = DWC2_L0;
+		goto unlock;
+	}
 
+	/* Change Root port status, as port status change occurred after resume.*/
+	hsotg->flags.b.port_suspend_change = 1;
 
-		/* Exit partial_power_down */
-		ret = dwc2_exit_partial_power_down(hsotg, true);
-		if (ret && (ret != -ENOTSUPP))
-			dev_err(hsotg->dev, "exit partial_power_down failed\n");
-	} else {
-		pcgctl = readl(hsotg->regs + PCGCTL);
-		pcgctl &= ~PCGCTL_STOPPCLK;
-		writel(pcgctl, hsotg->regs + PCGCTL);
+	/*
+	 * Enable power if not already done.
+	 * This must not be spinlocked since duration
+	 * of this call is unknown.
+	 */
+	if (!IS_ERR_OR_NULL(hsotg->uphy)) {
+		spin_unlock_irqrestore(&hsotg->lock, flags);
+		usb_phy_set_suspend(hsotg->uphy, false);
+		spin_lock_irqsave(&hsotg->lock, flags);
 	}
 
-	hsotg->lx_state = DWC2_L0;
-
+	/* Enable external vbus supply after resuming the port. */
 	spin_unlock_irqrestore(&hsotg->lock, flags);
+	dwc2_vbus_supply_init(hsotg);
 
-	if (hsotg->bus_suspended) {
-		spin_lock_irqsave(&hsotg->lock, flags);
-		hsotg->flags.b.port_suspend_change = 1;
-		spin_unlock_irqrestore(&hsotg->lock, flags);
-		dwc2_port_resume(hsotg);
-	} else {
-		if (hsotg->params.power_down == DWC2_POWER_DOWN_PARAM_PARTIAL) {
-			dwc2_vbus_supply_init(hsotg);
-
-			/* Wait for controller to correctly update D+/D- level */
-			usleep_range(3000, 5000);
-		}
+	/* Wait for controller to correctly update D+/D- level */
+	usleep_range(3000, 5000);
+	spin_lock_irqsave(&hsotg->lock, flags);
 
-		/*
-		 * Clear Port Enable and Port Status changes.
-		 * Enable Port Power.
-		 */
-		dwc2_writel(hsotg, HPRT0_PWR | HPRT0_CONNDET |
-				HPRT0_ENACHG, HPRT0);
-		/* Wait for controller to detect Port Connect */
-		usleep_range(5000, 7000);
-	}
+	/*
+	 * Clear Port Enable and Port Status changes.
+	 * Enable Port Power.
+	 */
+	dwc2_writel(hsotg, HPRT0_PWR | HPRT0_CONNDET |
+			HPRT0_ENACHG, HPRT0);
 
-	return ret;
+	/* Wait for controller to detect Port Connect */
+	spin_unlock_irqrestore(&hsotg->lock, flags);
+	usleep_range(5000, 7000);
+	spin_lock_irqsave(&hsotg->lock, flags);
 unlock:
 	spin_unlock_irqrestore(&hsotg->lock, flags);
 
@@ -4563,12 +4655,41 @@ static int _dwc2_hcd_urb_enqueue(struct
 	struct dwc2_qh *qh;
 	bool qh_allocated = false;
 	struct dwc2_qtd *qtd;
+	struct dwc2_gregs_backup *gr;
+
+	gr = &hsotg->gr_backup;
 
 	if (dbg_urb(urb)) {
 		dev_vdbg(hsotg->dev, "DWC OTG HCD URB Enqueue\n");
 		dwc2_dump_urb_info(hcd, urb, "urb_enqueue");
 	}
 
+	if (hsotg->hibernated) {
+		if (gr->gotgctl & GOTGCTL_CURMODE_HOST)
+			retval = dwc2_exit_hibernation(hsotg, 0, 0, 1);
+		else
+			retval = dwc2_exit_hibernation(hsotg, 0, 0, 0);
+
+		if (retval)
+			dev_err(hsotg->dev,
+				"exit hibernation failed.\n");
+	}
+
+	if (hsotg->in_ppd) {
+		retval = dwc2_exit_partial_power_down(hsotg, 0, true);
+		if (retval)
+			dev_err(hsotg->dev,
+				"exit partial_power_down failed\n");
+	}
+
+	if (hsotg->params.power_down == DWC2_POWER_DOWN_PARAM_NONE &&
+	    hsotg->bus_suspended) {
+		if (dwc2_is_device_mode(hsotg))
+			dwc2_gadget_exit_clock_gating(hsotg, 0);
+		else
+			dwc2_host_exit_clock_gating(hsotg, 0);
+	}
+
 	if (!ep)
 		return -EINVAL;
 
@@ -5397,7 +5518,7 @@ int dwc2_host_enter_hibernation(struct d
 	dwc2_writel(hsotg, hprt0, HPRT0);
 
 	/* Wait for the HPRT0.PrtSusp register field to be set */
-	if (dwc2_hsotg_wait_bit_set(hsotg, HPRT0, HPRT0_SUSP, 3000))
+	if (dwc2_hsotg_wait_bit_set(hsotg, HPRT0, HPRT0_SUSP, 5000))
 		dev_warn(hsotg->dev, "Suspend wasn't generated\n");
 
 	/*
@@ -5578,7 +5699,15 @@ int dwc2_host_exit_hibernation(struct dw
 		return ret;
 	}
 
-	dwc2_hcd_rem_wakeup(hsotg);
+	if (rem_wakeup) {
+		dwc2_hcd_rem_wakeup(hsotg);
+		/*
+		 * Change "port_connect_status_change" flag to re-enumerate,
+		 * because after exit from hibernation port connection status
+		 * is not detected.
+		 */
+		hsotg->flags.b.port_connect_status_change = 1;
+	}
 
 	hsotg->hibernated = 0;
 	hsotg->bus_suspended = 0;
@@ -5605,3 +5734,249 @@ bool dwc2_host_can_poweroff_phy(struct d
 	/* No reason to keep the PHY powered, so allow poweroff */
 	return true;
 }
+
+/**
+ * dwc2_host_enter_partial_power_down() - Put controller in partial
+ * power down.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ *
+ * Return: non-zero if failed to enter host partial power down.
+ *
+ * This function is for entering Host mode partial power down.
+ */
+int dwc2_host_enter_partial_power_down(struct dwc2_hsotg *hsotg)
+{
+	u32 pcgcctl;
+	u32 hprt0;
+	int ret = 0;
+
+	dev_dbg(hsotg->dev, "Entering host partial power down started.\n");
+
+	/* Put this port in suspend mode. */
+	hprt0 = dwc2_read_hprt0(hsotg);
+	hprt0 |= HPRT0_SUSP;
+	dwc2_writel(hsotg, hprt0, HPRT0);
+	udelay(5);
+
+	/* Wait for the HPRT0.PrtSusp register field to be set */
+	if (dwc2_hsotg_wait_bit_set(hsotg, HPRT0, HPRT0_SUSP, 3000))
+		dev_warn(hsotg->dev, "Suspend wasn't generated\n");
+
+	/* Backup all registers */
+	ret = dwc2_backup_global_registers(hsotg);
+	if (ret) {
+		dev_err(hsotg->dev, "%s: failed to backup global registers\n",
+			__func__);
+		return ret;
+	}
+
+	ret = dwc2_backup_host_registers(hsotg);
+	if (ret) {
+		dev_err(hsotg->dev, "%s: failed to backup host registers\n",
+			__func__);
+		return ret;
+	}
+
+	/*
+	 * Clear any pending interrupts since dwc2 will not be able to
+	 * clear them after entering partial_power_down.
+	 */
+	dwc2_writel(hsotg, 0xffffffff, GINTSTS);
+
+	/* Put the controller in low power state */
+	pcgcctl = dwc2_readl(hsotg, PCGCTL);
+
+	pcgcctl |= PCGCTL_PWRCLMP;
+	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+	udelay(5);
+
+	pcgcctl |= PCGCTL_RSTPDWNMODULE;
+	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+	udelay(5);
+
+	pcgcctl |= PCGCTL_STOPPCLK;
+	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+
+	/* Set in_ppd flag to 1 as here core enters suspend. */
+	hsotg->in_ppd = 1;
+	hsotg->lx_state = DWC2_L2;
+	hsotg->bus_suspended = true;
+
+	dev_dbg(hsotg->dev, "Entering host partial power down completed.\n");
+
+	return ret;
+}
+
+/*
+ * dwc2_host_exit_partial_power_down() - Exit controller from host partial
+ * power down.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ * @rem_wakeup: indicates whether resume is initiated by Reset.
+ * @restore: indicates whether need to restore the registers or not.
+ *
+ * Return: non-zero if failed to exit host partial power down.
+ *
+ * This function is for exiting from Host mode partial power down.
+ */
+int dwc2_host_exit_partial_power_down(struct dwc2_hsotg *hsotg,
+				      int rem_wakeup, bool restore)
+{
+	u32 pcgcctl;
+	int ret = 0;
+	u32 hprt0;
+
+	dev_dbg(hsotg->dev, "Exiting host partial power down started.\n");
+
+	pcgcctl = dwc2_readl(hsotg, PCGCTL);
+	pcgcctl &= ~PCGCTL_STOPPCLK;
+	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+	udelay(5);
+
+	pcgcctl = dwc2_readl(hsotg, PCGCTL);
+	pcgcctl &= ~PCGCTL_PWRCLMP;
+	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+	udelay(5);
+
+	pcgcctl = dwc2_readl(hsotg, PCGCTL);
+	pcgcctl &= ~PCGCTL_RSTPDWNMODULE;
+	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+
+	udelay(100);
+	if (restore) {
+		ret = dwc2_restore_global_registers(hsotg);
+		if (ret) {
+			dev_err(hsotg->dev, "%s: failed to restore registers\n",
+				__func__);
+			return ret;
+		}
+
+		ret = dwc2_restore_host_registers(hsotg);
+		if (ret) {
+			dev_err(hsotg->dev, "%s: failed to restore host registers\n",
+				__func__);
+			return ret;
+		}
+	}
+
+	/* Drive resume signaling and exit suspend mode on the port. */
+	hprt0 = dwc2_read_hprt0(hsotg);
+	hprt0 |= HPRT0_RES;
+	hprt0 &= ~HPRT0_SUSP;
+	dwc2_writel(hsotg, hprt0, HPRT0);
+	udelay(5);
+
+	if (!rem_wakeup) {
+		/* Stop driveing resume signaling on the port. */
+		hprt0 = dwc2_read_hprt0(hsotg);
+		hprt0 &= ~HPRT0_RES;
+		dwc2_writel(hsotg, hprt0, HPRT0);
+
+		hsotg->bus_suspended = false;
+	} else {
+		/* Turn on the port power bit. */
+		hprt0 = dwc2_read_hprt0(hsotg);
+		hprt0 |= HPRT0_PWR;
+		dwc2_writel(hsotg, hprt0, HPRT0);
+
+		/* Connect hcd. */
+		dwc2_hcd_connect(hsotg);
+
+		mod_timer(&hsotg->wkp_timer,
+			  jiffies + msecs_to_jiffies(71));
+	}
+
+	/* Set lx_state to and in_ppd to 0 as here core exits from suspend. */
+	hsotg->in_ppd = 0;
+	hsotg->lx_state = DWC2_L0;
+
+	dev_dbg(hsotg->dev, "Exiting host partial power down completed.\n");
+	return ret;
+}
+
+/**
+ * dwc2_host_enter_clock_gating() - Put controller in clock gating.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ *
+ * This function is for entering Host mode clock gating.
+ */
+void dwc2_host_enter_clock_gating(struct dwc2_hsotg *hsotg)
+{
+	u32 hprt0;
+	u32 pcgctl;
+
+	dev_dbg(hsotg->dev, "Entering host clock gating.\n");
+
+	/* Put this port in suspend mode. */
+	hprt0 = dwc2_read_hprt0(hsotg);
+	hprt0 |= HPRT0_SUSP;
+	dwc2_writel(hsotg, hprt0, HPRT0);
+
+	/* Set the Phy Clock bit as suspend is received. */
+	pcgctl = dwc2_readl(hsotg, PCGCTL);
+	pcgctl |= PCGCTL_STOPPCLK;
+	dwc2_writel(hsotg, pcgctl, PCGCTL);
+	udelay(5);
+
+	/* Set the Gate hclk as suspend is received. */
+	pcgctl = dwc2_readl(hsotg, PCGCTL);
+	pcgctl |= PCGCTL_GATEHCLK;
+	dwc2_writel(hsotg, pcgctl, PCGCTL);
+	udelay(5);
+
+	hsotg->bus_suspended = true;
+	hsotg->lx_state = DWC2_L2;
+}
+
+/**
+ * dwc2_host_exit_clock_gating() - Exit controller from clock gating.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ * @rem_wakeup: indicates whether resume is initiated by remote wakeup
+ *
+ * This function is for exiting Host mode clock gating.
+ */
+void dwc2_host_exit_clock_gating(struct dwc2_hsotg *hsotg, int rem_wakeup)
+{
+	u32 hprt0;
+	u32 pcgctl;
+
+	dev_dbg(hsotg->dev, "Exiting host clock gating.\n");
+
+	/* Clear the Gate hclk. */
+	pcgctl = dwc2_readl(hsotg, PCGCTL);
+	pcgctl &= ~PCGCTL_GATEHCLK;
+	dwc2_writel(hsotg, pcgctl, PCGCTL);
+	udelay(5);
+
+	/* Phy Clock bit. */
+	pcgctl = dwc2_readl(hsotg, PCGCTL);
+	pcgctl &= ~PCGCTL_STOPPCLK;
+	dwc2_writel(hsotg, pcgctl, PCGCTL);
+	udelay(5);
+
+	/* Drive resume signaling and exit suspend mode on the port. */
+	hprt0 = dwc2_read_hprt0(hsotg);
+	hprt0 |= HPRT0_RES;
+	hprt0 &= ~HPRT0_SUSP;
+	dwc2_writel(hsotg, hprt0, HPRT0);
+	udelay(5);
+
+	if (!rem_wakeup) {
+		/* In case of port resume need to wait for 40 ms */
+		msleep(USB_RESUME_TIMEOUT);
+
+		/* Stop driveing resume signaling on the port. */
+		hprt0 = dwc2_read_hprt0(hsotg);
+		hprt0 &= ~HPRT0_RES;
+		dwc2_writel(hsotg, hprt0, HPRT0);
+
+		hsotg->bus_suspended = false;
+		hsotg->lx_state = DWC2_L0;
+	} else {
+		mod_timer(&hsotg->wkp_timer,
+			  jiffies + msecs_to_jiffies(71));
+	}
+}
diff -urpN --no-dereference -X diffgen.ignore test-tree/drivers/usb/dwc2/hcd_intr.c milky/drivers/usb/dwc2/hcd_intr.c
--- test-tree/drivers/usb/dwc2/hcd_intr.c	2024-06-01 13:18:41.876500271 -0400
+++ milky/drivers/usb/dwc2/hcd_intr.c	2024-05-21 05:22:27.000000000 -0400
@@ -500,7 +500,7 @@ static int dwc2_update_urb_state(struct
 						      &short_read);
 
 	if (urb->actual_length + xfer_length > urb->length) {
-		dev_warn(hsotg->dev, "%s(): trimming xfer length\n", __func__);
+		dev_dbg(hsotg->dev, "%s(): trimming xfer length\n", __func__);
 		xfer_length = urb->length - urb->actual_length;
 	}
 
@@ -1958,6 +1958,23 @@ static void dwc2_hc_chhltd_intr_dma(stru
 				dwc2_halt_channel(hsotg, chan, qtd,
 					DWC2_HC_XFER_PERIODIC_INCOMPLETE);
 			} else {
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+				dev_info(hsotg->dev,
+					"%s: Channel %d - ChHltd set, but reason is unknown, ignore it\n",
+					__func__, chnum);
+				dev_info(hsotg->dev,
+					"hcint 0x%08x, intsts 0x%08x\n",
+					chan->hcint,
+					dwc2_readl(hsotg, GINTSTS));
+				/* Unknown halt reason.
+				 * From the catc, the device returns an incomplete transaction
+				 * but recovers by the USB bus level error handling (resend).
+				 * Make it a successful transaction anyway and let the function
+				 * driver check the content.
+				 */
+				dwc2_hc_xfercomp_intr(hsotg, chan, chnum, qtd);
+			}
+#else
 				dev_err(hsotg->dev,
 					"%s: Channel %d - ChHltd set, but reason is unknown\n",
 					__func__, chnum);
@@ -1966,17 +1983,31 @@ static void dwc2_hc_chhltd_intr_dma(stru
 					chan->hcint,
 					dwc2_readl(hsotg, GINTSTS));
 				goto error;
-			}
+#endif
 		}
 	} else {
 		dev_info(hsotg->dev,
 			 "NYET/NAK/ACK/other in non-error case, 0x%08x\n",
 			 chan->hcint);
+#if !IS_ENABLED(CONFIG_ARCH_CVITEK)
 error:
+#endif
 		/* Failthrough: use 3-strikes rule */
 		qtd->error_count++;
 		dwc2_update_urb_state_abn(hsotg, chan, chnum, qtd->urb,
 					  qtd, DWC2_HC_XFER_XACT_ERR);
+		/*
+		 * We can get here after a completed transaction
+		 * (urb->actual_length >= urb->length) which was not reported
+		 * as completed. If that is the case, and we do not abort
+		 * the transfer, a transfer of size 0 will be enqueued
+		 * subsequently. If urb->actual_length is not DMA-aligned,
+		 * the buffer will then point to an unaligned address, and
+		 * the resulting behavior is undefined. Bail out in that
+		 * situation.
+		 */
+		if (qtd->urb->actual_length >= qtd->urb->length)
+			qtd->error_count = 3;
 		dwc2_hcd_save_data_toggle(hsotg, chan, chnum, qtd);
 		dwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_XACT_ERR);
 	}
diff -urpN --no-dereference -X diffgen.ignore test-tree/drivers/usb/dwc2/hcd_queue.c milky/drivers/usb/dwc2/hcd_queue.c
--- test-tree/drivers/usb/dwc2/hcd_queue.c	2024-06-01 13:18:41.876500271 -0400
+++ milky/drivers/usb/dwc2/hcd_queue.c	2024-05-21 05:22:27.000000000 -0400
@@ -59,7 +59,7 @@
 #define DWC2_UNRESERVE_DELAY (msecs_to_jiffies(5))
 
 /* If we get a NAK, wait this long before retrying */
-#define DWC2_RETRY_WAIT_DELAY 1*1E6L
+#define DWC2_RETRY_WAIT_DELAY (1 * 1E6L)
 
 /**
  * dwc2_periodic_channel_available() - Checks that a channel is available for a
diff -urpN --no-dereference -X diffgen.ignore test-tree/drivers/usb/dwc2/hw.h milky/drivers/usb/dwc2/hw.h
--- test-tree/drivers/usb/dwc2/hw.h	2024-06-01 13:18:41.876500271 -0400
+++ milky/drivers/usb/dwc2/hw.h	2024-05-21 05:22:27.000000000 -0400
@@ -44,6 +44,7 @@
 #define GOTGCTL_CHIRPEN			BIT(27)
 #define GOTGCTL_MULT_VALID_BC_MASK	(0x1f << 22)
 #define GOTGCTL_MULT_VALID_BC_SHIFT	22
+#define GOTGCTL_CURMODE_HOST		BIT(21)
 #define GOTGCTL_OTGVER			BIT(20)
 #define GOTGCTL_BSESVLD			BIT(19)
 #define GOTGCTL_ASESVLD			BIT(18)
diff -urpN --no-dereference -X diffgen.ignore test-tree/drivers/usb/dwc2/params.c milky/drivers/usb/dwc2/params.c
--- test-tree/drivers/usb/dwc2/params.c	2024-06-01 13:18:41.876500271 -0400
+++ milky/drivers/usb/dwc2/params.c	2024-05-21 05:22:27.000000000 -0400
@@ -163,34 +163,31 @@ static void dwc2_set_stm32f7_hsotg_param
 	p->host_perio_tx_fifo_size = 256;
 }
 
-static void dwc2_set_stm32mp15_fsotg_params(struct dwc2_hsotg *hsotg)
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+static void dwc2_set_cv182x_params(struct dwc2_hsotg *hsotg)
 {
 	struct dwc2_core_params *p = &hsotg->params;
 
 	p->otg_cap = DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE;
-	p->speed = DWC2_SPEED_PARAM_FULL;
-	p->host_rx_fifo_size = 128;
-	p->host_nperio_tx_fifo_size = 96;
-	p->host_perio_tx_fifo_size = 96;
-	p->max_packet_count = 256;
-	p->phy_type = DWC2_PHY_TYPE_PARAM_FS;
-	p->i2c_enable = false;
-	p->activate_stm_fs_transceiver = true;
-	p->activate_stm_id_vb_detection = true;
-	p->power_down = DWC2_POWER_DOWN_PARAM_NONE;
-}
-
-static void dwc2_set_stm32mp15_hsotg_params(struct dwc2_hsotg *hsotg)
-{
-	struct dwc2_core_params *p = &hsotg->params;
-
-	p->otg_cap = DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE;
-	p->activate_stm_id_vb_detection = !device_property_read_bool(hsotg->dev, "usb-role-switch");
-	p->host_rx_fifo_size = 440;
-	p->host_nperio_tx_fifo_size = 256;
-	p->host_perio_tx_fifo_size = 256;
+	p->speed = DWC2_SPEED_PARAM_HIGH;
+	p->phy_type = DWC2_PHY_TYPE_PARAM_UTMI;
+	p->ahbcfg = GAHBCFG_HBSTLEN_INCR16 << GAHBCFG_HBSTLEN_SHIFT;
+	p->phy_utmi_width = 16;
+	p->g_dma = 1;
+	p->g_dma_desc = 1;
+	p->lpm = false;
+	p->lpm_clock_gating = false;
+	p->besl = false;
+	p->hird_threshold_en = false;
+	p->max_packet_count = (1 << 10) - 1;
+	p->max_transfer_size = (1 << 19) - 1;
+	p->reload_ctl = 0;
+	p->enable_dynamic_fifo = true;
+	p->en_multiple_tx_fifo = true;
+	/* [TODO] shall we power down this ?*/
 	p->power_down = DWC2_POWER_DOWN_PARAM_NONE;
 }
+#endif
 
 const struct of_device_id dwc2_of_match_table[] = {
 	{ .compatible = "brcm,bcm2835-usb", .data = dwc2_set_bcm_params },
@@ -216,10 +213,10 @@ const struct of_device_id dwc2_of_match_
 	{ .compatible = "st,stm32f4x9-hsotg" },
 	{ .compatible = "st,stm32f7-hsotg",
 	  .data = dwc2_set_stm32f7_hsotg_params },
-	{ .compatible = "st,stm32mp15-fsotg",
-	  .data = dwc2_set_stm32mp15_fsotg_params },
-	{ .compatible = "st,stm32mp15-hsotg",
-	  .data = dwc2_set_stm32mp15_hsotg_params },
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	{ .compatible = "cvitek,cv182x-usb",
+	  .data = dwc2_set_cv182x_params },
+#endif
 	{},
 };
 MODULE_DEVICE_TABLE(of, dwc2_of_match_table);
@@ -858,10 +855,12 @@ int dwc2_get_hwparams(struct dwc2_hsotg
 	return 0;
 }
 
+typedef void (*set_params_cb)(struct dwc2_hsotg *data);
+
 int dwc2_init_params(struct dwc2_hsotg *hsotg)
 {
 	const struct of_device_id *match;
-	void (*set_params)(struct dwc2_hsotg *data);
+	set_params_cb set_params;
 
 	dwc2_set_default_params(hsotg);
 	dwc2_get_device_properties(hsotg);
diff -urpN --no-dereference -X diffgen.ignore test-tree/drivers/usb/dwc2/pci.c milky/drivers/usb/dwc2/pci.c
--- test-tree/drivers/usb/dwc2/pci.c	2024-06-01 13:18:41.876500271 -0400
+++ milky/drivers/usb/dwc2/pci.c	2024-05-21 05:22:27.000000000 -0400
@@ -63,20 +63,6 @@ struct dwc2_pci_glue {
 	struct platform_device *phy;
 };
 
-static int dwc2_pci_quirks(struct pci_dev *pdev, struct platform_device *dwc2)
-{
-	if (pdev->vendor == PCI_VENDOR_ID_SYNOPSYS &&
-	    pdev->device == PCI_PRODUCT_ID_HAPS_HSOTG) {
-		struct property_entry properties[] = {
-			{ },
-		};
-
-		return platform_device_add_properties(dwc2, properties);
-	}
-
-	return 0;
-}
-
 /**
  * dwc2_pci_probe() - Provides the cleanup entry points for the DWC_otg PCI
  * driver
@@ -143,10 +129,6 @@ static int dwc2_pci_probe(struct pci_dev
 
 	dwc2->dev.parent = dev;
 
-	ret = dwc2_pci_quirks(pci, dwc2);
-	if (ret)
-		goto err;
-
 	glue = devm_kzalloc(dev, sizeof(*glue), GFP_KERNEL);
 	if (!glue) {
 		ret = -ENOMEM;
diff -urpN --no-dereference -X diffgen.ignore test-tree/drivers/usb/dwc2/platform.c milky/drivers/usb/dwc2/platform.c
--- test-tree/drivers/usb/dwc2/platform.c	2024-06-01 13:18:41.876500271 -0400
+++ milky/drivers/usb/dwc2/platform.c	2024-05-21 05:22:27.000000000 -0400
@@ -47,6 +47,7 @@
 #include <linux/phy/phy.h>
 #include <linux/platform_data/s3c-hsotg.h>
 #include <linux/reset.h>
+#include <linux/of_gpio.h>
 
 #include <linux/usb/of.h>
 
@@ -54,6 +55,15 @@
 #include "hcd.h"
 #include "debug.h"
 
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+#include <linux/ctype.h>
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/uaccess.h>
+#endif
+#endif
+
 static const char dwc2_driver_name[] = "dwc2";
 
 /*
@@ -128,10 +138,28 @@ static void __dwc2_disable_regulators(vo
 	regulator_bulk_disable(ARRAY_SIZE(hsotg->supplies), hsotg->supplies);
 }
 
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+static void dwc2_set_hw_id(struct dwc2_hsotg *hsotg, int is_dev)
+{
+	if (is_dev) {
+		/* device */
+		iowrite32((ioread32((void *)hsotg->cviusb.usb_pin_regs) & ~0x0000C0) | 0xC0,
+				(void *)hsotg->cviusb.usb_pin_regs);
+	} else {
+		/* host */
+		iowrite32((ioread32((void *)hsotg->cviusb.usb_pin_regs) & ~0x0000C0) | 0x40,
+				(void *)hsotg->cviusb.usb_pin_regs);
+	}
+}
+#endif
+
 static int __dwc2_lowlevel_hw_enable(struct dwc2_hsotg *hsotg)
 {
 	struct platform_device *pdev = to_platform_device(hsotg->dev);
 	int ret;
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	struct cviusb_dev *cviusb = &hsotg->cviusb;
+#endif
 
 	ret = regulator_bulk_enable(ARRAY_SIZE(hsotg->supplies),
 				    hsotg->supplies);
@@ -149,6 +177,37 @@ static int __dwc2_lowlevel_hw_enable(str
 			return ret;
 	}
 
+	/* Enable the clock here for init/resume process. */
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	if (!IS_ERR(cviusb->clk_axi.clk_o)) {
+		clk_prepare_enable(cviusb->clk_axi.clk_o);
+		cviusb->clk_axi.is_on = 1;
+		dev_info(hsotg->dev, "axi clk installed\n");
+	}
+	if (!IS_ERR(cviusb->clk_apb.clk_o)) {
+		clk_prepare_enable(cviusb->clk_apb.clk_o);
+		cviusb->clk_apb.is_on = 1;
+		dev_info(hsotg->dev, "apb clk installed\n");
+	}
+	if (!IS_ERR(cviusb->clk_125m.clk_o)) {
+		clk_prepare_enable(cviusb->clk_125m.clk_o);
+		cviusb->clk_125m.is_on = 1;
+		dev_info(hsotg->dev, "125m clk installed\n");
+	}
+	if (!IS_ERR(cviusb->clk_33k.clk_o)) {
+		clk_prepare_enable(cviusb->clk_33k.clk_o);
+		cviusb->clk_33k.is_on = 1;
+		dev_info(hsotg->dev, "33k clk installed\n");
+	}
+	if (!IS_ERR(cviusb->clk_12m.clk_o)) {
+		clk_prepare_enable(cviusb->clk_12m.clk_o);
+		cviusb->clk_12m.is_on = 1;
+		dev_info(hsotg->dev, "12m clk installed\n");
+	}
+
+	dwc2_set_hw_id(hsotg, hsotg->cviusb.id_override);
+#endif
+
 	if (hsotg->uphy) {
 		ret = usb_phy_init(hsotg->uphy);
 	} else if (hsotg->plat && hsotg->plat->phy_init) {
@@ -280,13 +339,14 @@ static int dwc2_lowlevel_hw_init(struct
 
 	hsotg->plat = dev_get_platdata(hsotg->dev);
 
+#if !IS_ENABLED(CONFIG_ARCH_CVITEK)
 	/* Clock */
 	hsotg->clk = devm_clk_get_optional(hsotg->dev, "otg");
 	if (IS_ERR(hsotg->clk)) {
 		dev_err(hsotg->dev, "cannot get otg clock\n");
 		return PTR_ERR(hsotg->clk);
 	}
-
+#endif
 	/* Regulators */
 	for (i = 0; i < ARRAY_SIZE(hsotg->supplies); i++)
 		hsotg->supplies[i].supply = dwc2_hsotg_supply_names[i];
@@ -302,6 +362,401 @@ static int dwc2_lowlevel_hw_init(struct
 	return 0;
 }
 
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+
+#if IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL) || \
+	IS_ENABLED(CONFIG_USB_DWC2_DUAL_ROLE)
+
+#define PHY_REG(x)	(x)
+
+#define REG014				PHY_REG(0x014)
+#define REG014_UTMI_RESET		(1 << 8)
+#define REG014_DMPULLDOWN		(1 << 7)
+#define REG014_DPPULLDOWN		(1 << 6)
+#define REG014_TERMSEL			(1 << 5)
+#define REG014_XCVRSEL_MASK		(0x3 << 3)
+#define REG014_XCVRSEL_SHIFT		3
+#define REG014_OPMODE_MASK		(0x3 << 1)
+#define REG014_OPMODE_SHIFT		1
+#define REG014_UTMI_OVERRIDE		(1 << 0)
+
+#define REG020				PHY_REG(0x020)
+#define REG020_DP_DET			(1 << 17)
+#define REG020_CHG_DET			(1 << 16)
+#define REG020_VDM_SRC_EN		(1 << 5)
+#define REG020_VDP_SRC_EN		(1 << 4)
+#define REG020_DM_CMP_EN		(1 << 3)
+#define REG020_DP_CMP_EN		(1 << 2)
+#define REG020_DCD_EN			(1 << 1)
+#define REG020_BC_EN			(1 << 0)
+
+#ifdef CONFIG_PROC_FS
+
+#define CVIUSB_ROLE_PROC_NAME "cviusb/otg_role"
+#define CVIUSB_CHGDET_PROC_NAME "cviusb/chg_det"
+
+static struct proc_dir_entry *cviusb_proc_dir;
+static struct proc_dir_entry *cviusb_role_proc_entry;
+static struct proc_dir_entry *cviusb_chgdet_proc_entry;
+
+static u8 *sel_role[] = {
+	"host",
+	"device",
+};
+
+static int proc_role_show(struct seq_file *m, void *v)
+{
+	struct dwc2_hsotg *hsotg = (struct dwc2_hsotg *)m->private;
+
+	seq_printf(m, "%s\n", sel_role[hsotg->cviusb.id_override]);
+
+	return 0;
+}
+
+static int sel_role_hdler(struct dwc2_hsotg *hsotg, char const *input)
+{
+	u32 num;
+	u8 str[80] = {0};
+	u8 t = 0;
+	u8 i, n;
+	u8 *p;
+
+	num = sscanf(input, "%s", str);
+	if (num > 1) {
+		return -EINVAL;
+	}
+
+	/* convert to lower case for following type compare */
+	p = str;
+	for (; *p; ++p)
+		*p = tolower(*p);
+	n = ARRAY_SIZE(sel_role);
+	for (i = 0; i < n; i++) {
+		if (!strcmp(str, sel_role[i])) {
+			t = i;
+			break;
+		}
+	}
+	if (i == n)
+		return -EINVAL;
+
+	hsotg->cviusb.id_override = t;
+	dwc2_set_hw_id(hsotg, t);
+
+	return 0;
+}
+
+static ssize_t role_proc_write(struct file *file, const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char procdata[32] = {'\0'};
+	struct dwc2_hsotg *hsotg = PDE_DATA(file_inode(file));
+
+	if (user_buf == NULL || count >= sizeof(procdata)) {
+		dev_err(hsotg->dev, "Invalid input value\n");
+		return -EINVAL;
+	}
+
+	if (copy_from_user(procdata, user_buf, count)) {
+		dev_err(hsotg->dev, "copy_from_user fail\n");
+		return -EFAULT;
+	}
+
+	sel_role_hdler(hsotg, procdata);
+
+	return count;
+}
+
+static int proc_role_open(struct inode *inode, struct file *file)
+{
+	struct dwc2_hsotg *hsotg = PDE_DATA(inode);
+
+	return single_open(file, proc_role_show, hsotg);
+}
+
+static const struct proc_ops role_proc_ops = {
+	.proc_open		= proc_role_open,
+	.proc_read		= seq_read,
+	.proc_write		= role_proc_write,
+	.proc_lseek		= seq_lseek,
+	.proc_release	= single_release,
+};
+
+#define TDCD_TIMEOUT_MAX	900	//ms
+#define TDCD_TIMEOUT_MIN	300	//ms
+#define TDCD_DBNC		10	//ms
+#define TVDMSRC_EN		20	//ms
+#define TVDPSRC_ON		40	//ms
+#define TVDMSRC_ON		40	//ms
+
+static u8 *dcd_en[] = {
+	"dcd_off",
+	"dcd_on",
+};
+
+static u8 *chg_port[CHGDET_NUM] = {
+	"sdp",
+	"dcp",
+	"cdp",
+};
+
+static void utmi_chgdet_prepare(struct dwc2_hsotg *hsotg)
+{
+	struct cviusb_dev *cviusb = &hsotg->cviusb;
+
+	cviusb_writel(REG014_UTMI_OVERRIDE |
+			(REG014_OPMODE_MASK & (0x1 << REG014_OPMODE_SHIFT)) |
+			(REG014_XCVRSEL_MASK & (0x1 << REG014_XCVRSEL_SHIFT)),
+			cviusb->phy_regs + REG014);
+}
+
+static void utmi_reset(struct dwc2_hsotg *hsotg)
+{
+	struct cviusb_dev *cviusb = &hsotg->cviusb;
+
+	cviusb_writel(0, cviusb->phy_regs + REG014);
+}
+
+static void dcd_det(struct dwc2_hsotg *hsotg)
+{
+	struct cviusb_dev *cviusb = &hsotg->cviusb;
+	int cnt = 0;
+	u32 dbnc = 0;
+
+	/* 1. utmi prepare */
+	utmi_chgdet_prepare(hsotg);
+	/* 2. Enable bc and dcd*/
+	cviusb_writel(REG020_BC_EN | REG020_DCD_EN, cviusb->phy_regs + REG020);
+	/* 3. DCD det in 900ms */
+	while (cnt++ < TDCD_TIMEOUT_MAX) {
+		if (!(dwc2_readl(hsotg, DSTS) & BIT(22)))
+			dbnc += 1;
+		else
+			dbnc = 0;
+		if (dbnc >= TDCD_DBNC)
+			break;
+		usleep_range(1000, 1010);
+	}
+	/* 4. Disable bc dcd. */
+	cviusb_writel(0, cviusb->phy_regs + REG020);
+	/* 5. utmi reset */
+	utmi_reset(hsotg);
+	usleep_range(1000, 1010);
+}
+
+static int chg_det(struct dwc2_hsotg *hsotg)
+{
+	struct cviusb_dev *cviusb = &hsotg->cviusb;
+	int cnt = 0;
+	int det = 0;
+	u32 reg;
+
+	/* 1. Enable bc */
+	cviusb_writel(REG020_BC_EN | REG020_VDP_SRC_EN | REG020_DM_CMP_EN,
+			cviusb->phy_regs + REG020);
+	/* need 2ms delay to avoid the unstable value on DM CMP. */
+	usleep_range(2000, 2010);
+	/* 2. Dm det in 40ms */
+	while (cnt++ < TVDPSRC_ON) {
+		reg = cviusb_readl(cviusb->phy_regs + REG020);
+		if (reg & REG020_CHG_DET)
+			det = 1;
+		if (!det && cnt > TVDMSRC_EN)
+			break;
+		usleep_range(1000, 1010);
+	}
+	/* 3. Disable bc. */
+	cviusb_writel(0, cviusb->phy_regs + REG020);
+
+	return det;
+}
+
+static int cdp_det(struct dwc2_hsotg *hsotg)
+{
+	struct cviusb_dev *cviusb = &hsotg->cviusb;
+	int cnt = 0;
+	int det = 0;
+
+	/* 1. Enable bc */
+	cviusb_writel(REG020_BC_EN | REG020_VDM_SRC_EN | REG020_DP_CMP_EN,
+			cviusb->phy_regs + REG020);
+	usleep_range(1000, 1010);
+	/* 2. Dp det in 40ms */
+	while (cnt++ < TVDMSRC_ON) {
+		if ((cviusb_readl(cviusb->phy_regs + REG020) & REG020_DP_DET))
+			det = 1;
+		/* 5ms for 2nd detection. */
+		if (!det && cnt > 5)
+			break;
+		usleep_range(1000, 1010);
+	}
+	/* 3. Disable bc. */
+	cviusb_writel(0, cviusb->phy_regs + REG020);
+
+	return !det;
+}
+
+static int proc_chgdet_show(struct seq_file *m, void *v)
+{
+	struct dwc2_hsotg *hsotg = (struct dwc2_hsotg *)m->private;
+	struct cviusb_dev *cviusb = &hsotg->cviusb;
+	u32 reg;
+
+	if (!hsotg->cviusb.id_override)
+		return -EPERM;
+
+	/* Disconnect the data line. */
+	reg = dwc2_readl(hsotg, DCTL) | DCTL_SFTDISCON;
+	dwc2_writel(hsotg, reg, DCTL);
+
+	/* Run dcd detection or wait TDCD_TIMEOUT_MIN. */
+	if (cviusb->dcd_dis)
+		msleep(TDCD_TIMEOUT_MIN);
+	else
+		dcd_det(hsotg);
+	/* Run chgdet */
+	if (chg_det(hsotg)) {
+		usleep_range(1000, 1010);
+		if (cdp_det(hsotg))
+			cviusb->chgdet = CHGDET_CDP;
+		else
+			cviusb->chgdet = CHGDET_DCP;
+	} else
+		cviusb->chgdet = CHGDET_SDP;
+
+	/* Run dcpdet */
+	seq_printf(m, "%s\n", chg_port[hsotg->cviusb.chgdet]);
+
+	return 0;
+}
+
+static int dcd_en_hdler(struct dwc2_hsotg *hsotg, char const *input)
+{
+	u32 num;
+	u8 str[80] = {0};
+	u8 t = 0;
+	u8 i, n;
+	u8 *p;
+
+	num = sscanf(input, "%s", str);
+	if (num > 1) {
+		return -EINVAL;
+	}
+
+	/* convert to lower case for following type compare */
+	p = str;
+	for (; *p; ++p)
+		*p = tolower(*p);
+	n = ARRAY_SIZE(dcd_en);
+	for (i = 0; i < n; i++) {
+		if (!strcmp(str, dcd_en[i])) {
+			t = i;
+			break;
+		}
+	}
+	if (i == n)
+		return -EINVAL;
+
+	switch (t) {
+	case 0:
+		/* dcd off */
+		hsotg->cviusb.dcd_dis = 1;
+		break;
+	case 1:
+		/* dcd on */
+		hsotg->cviusb.dcd_dis = 0;
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static ssize_t chgdet_proc_write(struct file *file, const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char procdata[32] = {'\0'};
+	struct dwc2_hsotg *hsotg = PDE_DATA(file_inode(file));
+
+	if (user_buf == NULL || count >= sizeof(procdata)) {
+		dev_err(hsotg->dev, "Invalid input value\n");
+		return -EINVAL;
+	}
+
+	if (copy_from_user(procdata, user_buf, count)) {
+		dev_err(hsotg->dev, "copy_from_user fail\n");
+		return -EFAULT;
+	}
+
+	dcd_en_hdler(hsotg, procdata);
+
+	return count;
+}
+
+static int proc_chgdet_open(struct inode *inode, struct file *file)
+{
+	struct dwc2_hsotg *hsotg = PDE_DATA(inode);
+
+	return single_open(file, proc_chgdet_show, hsotg);
+}
+
+static const struct proc_ops chgdet_proc_ops = {
+	.proc_open		= proc_chgdet_open,
+	.proc_read		= seq_read,
+	.proc_write		= chgdet_proc_write,
+	.proc_lseek		= seq_lseek,
+	.proc_release	= single_release,
+};
+
+#endif
+
+static int vbus_is_present(struct cviusb_dev *cviusb)
+{
+	if (gpio_is_valid(cviusb->vbus_pin))
+		return gpio_get_value(cviusb->vbus_pin) ^
+			cviusb->vbus_pin_inverted;
+
+	/* No Vbus detection: Assume always present */
+	return 1;
+}
+
+static irqreturn_t vbus_irq_handler(int irq, void *devid)
+{
+	struct cviusb_dev *cviusb = devid;
+	struct dwc2_hsotg *hsotg = container_of(cviusb, struct dwc2_hsotg, cviusb);
+	int vbus;
+
+	/* do nothing if we are an A-device (vbus provider). */
+	if (hsotg->op_state != OTG_STATE_B_PERIPHERAL)
+		return IRQ_HANDLED;
+	vbus = vbus_is_present(cviusb);
+	dev_dbg(hsotg->dev, "vbus int = %d\n", vbus);
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t vbus_irq_thread(int irq, void *devid)
+{
+	struct cviusb_dev *cviusb = devid;
+	struct dwc2_hsotg *hsotg = container_of(cviusb, struct dwc2_hsotg, cviusb);
+	struct usb_gadget *gadget = &hsotg->gadget;
+	int vbus;
+
+	if (!gadget->udc)
+		return IRQ_HANDLED;
+
+	/* debounce */
+	udelay(10);
+	vbus = vbus_is_present(cviusb);
+	if (cviusb->pre_vbus_status != vbus) {
+		dev_dbg(hsotg->dev, "vbus thread = %d\n", vbus);
+		usb_udc_vbus_handler(gadget, (vbus != 0));
+		cviusb->pre_vbus_status = vbus;
+	}
+	return IRQ_HANDLED;
+}
+#endif	/* CONFIG_USB_DWC2_PERIPHERAL || CONFIG_USB_DWC2_DUAL_ROLE */
+
+#endif	/* CONFIG_ARCH_CVITEK */
+
 /**
  * dwc2_driver_remove() - Called when the DWC_otg core is unregistered with the
  * DWC_otg driver
@@ -316,6 +771,46 @@ static int dwc2_lowlevel_hw_init(struct
 static int dwc2_driver_remove(struct platform_device *dev)
 {
 	struct dwc2_hsotg *hsotg = platform_get_drvdata(dev);
+	struct dwc2_gregs_backup *gr;
+	int ret = 0;
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	struct cviusb_dev *cviusb = &hsotg->cviusb;
+
+	devm_free_irq(&dev->dev,
+		      gpio_to_irq(hsotg->cviusb.vbus_pin),
+		      (void *)&hsotg->cviusb);
+#endif
+
+	gr = &hsotg->gr_backup;
+
+	/* Exit Hibernation when driver is removed. */
+	if (hsotg->hibernated) {
+		if (gr->gotgctl & GOTGCTL_CURMODE_HOST)
+			ret = dwc2_exit_hibernation(hsotg, 0, 0, 1);
+		else
+			ret = dwc2_exit_hibernation(hsotg, 0, 0, 0);
+
+		if (ret)
+			dev_err(hsotg->dev,
+				"exit hibernation failed.\n");
+	}
+
+	/* Exit Partial Power Down when driver is removed. */
+	if (hsotg->in_ppd) {
+		ret = dwc2_exit_partial_power_down(hsotg, 0, true);
+		if (ret)
+			dev_err(hsotg->dev,
+				"exit partial_power_down failed\n");
+	}
+
+	/* Exit clock gating when driver is removed. */
+	if (hsotg->params.power_down == DWC2_POWER_DOWN_PARAM_NONE &&
+	    hsotg->bus_suspended) {
+		if (dwc2_is_device_mode(hsotg))
+			dwc2_gadget_exit_clock_gating(hsotg, 0);
+		else
+			dwc2_host_exit_clock_gating(hsotg, 0);
+	}
 
 	dwc2_debugfs_exit(hsotg);
 	if (hsotg->hcd_enabled)
@@ -323,7 +818,9 @@ static int dwc2_driver_remove(struct pla
 	if (hsotg->gadget_enabled)
 		dwc2_hsotg_remove(hsotg);
 
+#if IS_ENABLED(CONFIG_USB_ROLE_SWITCH)
 	dwc2_drd_exit(hsotg);
+#endif
 
 	if (hsotg->params.activate_stm_id_vb_detection)
 		regulator_disable(hsotg->usb33d);
@@ -334,7 +831,50 @@ static int dwc2_driver_remove(struct pla
 	reset_control_assert(hsotg->reset);
 	reset_control_assert(hsotg->reset_ecc);
 
-	return 0;
+	/* Disable the clock here for remove process. */
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	if (cviusb->clk_axi.clk_o) {
+		clk_disable_unprepare(cviusb->clk_axi.clk_o);
+		dev_info(hsotg->dev, "axi clk disable\n");
+		cviusb->clk_axi.is_on = 0;
+	}
+	if (cviusb->clk_apb.clk_o) {
+		clk_disable_unprepare(cviusb->clk_apb.clk_o);
+		dev_info(hsotg->dev, "apb clk disable\n");
+		cviusb->clk_apb.is_on = 0;
+	}
+	if (cviusb->clk_125m.clk_o) {
+		clk_disable_unprepare(cviusb->clk_125m.clk_o);
+		dev_info(hsotg->dev, "125m clk disable\n");
+		cviusb->clk_125m.is_on = 0;
+	}
+	if (cviusb->clk_33k.clk_o) {
+		clk_disable_unprepare(cviusb->clk_33k.clk_o);
+		dev_info(hsotg->dev, "33k clk disable\n");
+		cviusb->clk_33k.is_on = 0;
+	}
+	if (cviusb->clk_12m.clk_o) {
+		clk_disable_unprepare(cviusb->clk_12m.clk_o);
+		dev_info(hsotg->dev, "12m clk disable\n");
+		cviusb->clk_12m.is_on = 0;
+	}
+
+#if IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL) || \
+	IS_ENABLED(CONFIG_USB_DWC2_DUAL_ROLE)
+
+#ifdef CONFIG_PROC_FS
+	proc_remove(cviusb_chgdet_proc_entry);
+	proc_remove(cviusb_role_proc_entry);
+	proc_remove(cviusb_proc_dir);
+	cviusb_proc_dir = NULL;
+	cviusb_role_proc_entry = NULL;
+#endif	/* CONFIG_PROC_FS */
+
+#endif	/* CONFIG_USB_DWC2_PERIPHERAL || CONFIG_USB_DWC2_DUAL_ROLE */
+
+#endif
+
+	return ret;
 }
 
 /**
@@ -422,6 +962,10 @@ static int dwc2_driver_probe(struct plat
 	struct dwc2_hsotg *hsotg;
 	struct resource *res;
 	int retval;
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	struct cviusb_dev *cviusb;
+	enum of_gpio_flags	flags;
+#endif
 
 	hsotg = devm_kzalloc(&dev->dev, sizeof(*hsotg), GFP_KERNEL);
 	if (!hsotg)
@@ -446,7 +990,40 @@ static int dwc2_driver_probe(struct plat
 
 	dev_dbg(&dev->dev, "mapped PA %08lx to VA %p\n",
 		(unsigned long)res->start, hsotg->regs);
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	cviusb = &hsotg->cviusb;
+	cviusb->usb_pin_regs = ioremap(0x03000048, 0x4);
+	/* init as host mode */
+	hsotg->cviusb.id_override = 0;
+	res = platform_get_resource(dev, IORESOURCE_MEM, 1);
+	cviusb->phy_regs = devm_ioremap_resource(&dev->dev, res);
+	if (IS_ERR(cviusb->phy_regs))
+		return PTR_ERR(cviusb->phy_regs);
+
+	dev_dbg(&dev->dev, "mapped PA %08lx to VA %p\n",
+		(unsigned long)res->start, cviusb->phy_regs);
 
+	cviusb->clk_axi.clk_o = devm_clk_get(&dev->dev, "clk_axi");
+	if (IS_ERR(cviusb->clk_axi.clk_o)) {
+		dev_warn(&dev->dev, "Clock axi not found\n");
+	}
+	cviusb->clk_apb.clk_o = devm_clk_get(&dev->dev, "clk_apb");
+	if (IS_ERR(cviusb->clk_apb.clk_o)) {
+		dev_warn(&dev->dev, "Clock apb not found\n");
+	}
+	cviusb->clk_125m.clk_o = devm_clk_get(&dev->dev, "clk_125m");
+	if (IS_ERR(cviusb->clk_125m.clk_o)) {
+		dev_warn(&dev->dev, "Clock 125m not found\n");
+	}
+	cviusb->clk_33k.clk_o = devm_clk_get(&dev->dev, "clk_33k");
+	if (IS_ERR(cviusb->clk_33k.clk_o)) {
+		dev_warn(&dev->dev, "Clock 33k not found\n");
+	}
+	cviusb->clk_12m.clk_o = devm_clk_get(&dev->dev, "clk_12m");
+	if (IS_ERR(cviusb->clk_12m.clk_o)) {
+		dev_warn(&dev->dev, "Clock 12m not found\n");
+	}
+#endif
 	retval = dwc2_lowlevel_hw_init(hsotg);
 	if (retval)
 		return retval;
@@ -477,6 +1054,10 @@ static int dwc2_driver_probe(struct plat
 	if (retval)
 		return retval;
 
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	/* Not to eanble the GINtMSK till all isr are ready. */
+	dwc2_writel(hsotg, 0, GINTMSK);
+#endif
 	hsotg->needs_byte_swap = dwc2_check_core_endianness(hsotg);
 
 	retval = dwc2_get_dr_mode(hsotg);
@@ -544,12 +1125,14 @@ static int dwc2_driver_probe(struct plat
 		dwc2_writel(hsotg, ggpio, GGPIO);
 	}
 
+#if IS_ENABLED(CONFIG_USB_ROLE_SWITCH)
 	retval = dwc2_drd_init(hsotg);
 	if (retval) {
 		if (retval != -EPROBE_DEFER)
 			dev_err(hsotg->dev, "failed to initialize dual-role\n");
 		goto error_init;
 	}
+#endif
 
 	if (hsotg->dr_mode != USB_DR_MODE_HOST) {
 		retval = dwc2_gadget_init(hsotg);
@@ -606,6 +1189,62 @@ static int dwc2_driver_probe(struct plat
 		}
 	}
 #endif /* CONFIG_USB_DWC2_PERIPHERAL || CONFIG_USB_DWC2_DUAL_ROLE */
+
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+
+#if IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL) || \
+	IS_ENABLED(CONFIG_USB_DWC2_DUAL_ROLE)
+
+	hsotg->cviusb.vbus_pin = of_get_named_gpio_flags(dev->dev.of_node,
+				"vbus-gpio", 0, &flags);
+	hsotg->cviusb.vbus_pin_inverted = (flags & OF_GPIO_ACTIVE_LOW) ? 1 : 0;
+	dev_dbg(hsotg->dev, "vbus_pin = %d, flags = %d\n",
+			hsotg->cviusb.vbus_pin, hsotg->cviusb.vbus_pin_inverted);
+	if (gpio_is_valid(hsotg->cviusb.vbus_pin)) {
+		if (!devm_gpio_request(&dev->dev,
+			hsotg->cviusb.vbus_pin, "cviusb-otg")) {
+			irq_set_status_flags(gpio_to_irq(hsotg->cviusb.vbus_pin),
+					IRQ_NOAUTOEN);
+			retval = devm_request_threaded_irq(&dev->dev,
+					gpio_to_irq(hsotg->cviusb.vbus_pin),
+					vbus_irq_handler,
+					vbus_irq_thread,
+					IRQF_TRIGGER_RISING |
+					IRQF_TRIGGER_FALLING,
+					"cviusb-otg", (void *)&hsotg->cviusb);
+			if (retval) {
+				hsotg->cviusb.vbus_pin = -ENODEV;
+				dev_err(hsotg->dev,
+					"failed to request vbus irq\n");
+			} else {
+				hsotg->cviusb.pre_vbus_status = vbus_is_present(&hsotg->cviusb);
+				enable_irq(gpio_to_irq(hsotg->cviusb.vbus_pin));
+				dev_dbg(hsotg->dev,
+					"enable vbus irq, vbus status = %d\n",
+					hsotg->cviusb.pre_vbus_status);
+			}
+		} else {
+			/* gpio_request fail so use -EINVAL for gpio_is_valid */
+			hsotg->cviusb.vbus_pin = -EINVAL;
+			dev_err(hsotg->dev, "request gpio fail!\n");
+		}
+	}
+
+#ifdef CONFIG_PROC_FS
+	cviusb_proc_dir = proc_mkdir("cviusb", NULL);
+	cviusb_role_proc_entry = proc_create_data(CVIUSB_ROLE_PROC_NAME, 0644, NULL,
+					  &role_proc_ops, hsotg);
+	if (!cviusb_role_proc_entry)
+		dev_err(&dev->dev, "cviusb: can't role procfs.\n");
+	cviusb_chgdet_proc_entry = proc_create_data(CVIUSB_CHGDET_PROC_NAME, 0644, NULL,
+					  &chgdet_proc_ops, hsotg);
+	if (!cviusb_chgdet_proc_entry)
+		dev_err(&dev->dev, "cviusb: can't chgdet procfs.\n");
+#endif	/* CONFIG_PROC_FS */
+
+#endif	/* CONFIG_USB_DWC2_PERIPHERAL || CONFIG_USB_DWC2_DUAL_ROLE */
+
+#endif	/* CONFIG_ARCH_CVITEK */
 	return 0;
 
 #if IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL) || \
@@ -615,8 +1254,11 @@ error_debugfs:
 	if (hsotg->hcd_enabled)
 		dwc2_hcd_remove(hsotg);
 #endif
+
 error_drd:
+#if IS_ENABLED(CONFIG_USB_ROLE_SWITCH)
 	dwc2_drd_exit(hsotg);
+#endif
 
 error_init:
 	if (hsotg->params.activate_stm_id_vb_detection)
diff -urpN --no-dereference -X diffgen.ignore test-tree/drivers/usb/gadget/composite.c milky/drivers/usb/gadget/composite.c
--- test-tree/drivers/usb/gadget/composite.c	2024-06-01 13:18:41.880500258 -0400
+++ milky/drivers/usb/gadget/composite.c	2024-05-21 05:22:27.000000000 -0400
@@ -392,8 +392,11 @@ int usb_function_deactivate(struct usb_f
 
 	spin_lock_irqsave(&cdev->lock, flags);
 
-	if (cdev->deactivations == 0)
+	if (cdev->deactivations == 0) {
+		spin_unlock_irqrestore(&cdev->lock, flags);
 		status = usb_gadget_deactivate(cdev->gadget);
+		spin_lock_irqsave(&cdev->lock, flags);
+	}
 	if (status == 0)
 		cdev->deactivations++;
 
@@ -424,8 +427,11 @@ int usb_function_activate(struct usb_fun
 		status = -EINVAL;
 	else {
 		cdev->deactivations--;
-		if (cdev->deactivations == 0)
+		if (cdev->deactivations == 0) {
+			spin_unlock_irqrestore(&cdev->lock, flags);
 			status = usb_gadget_activate(cdev->gadget);
+			spin_lock_irqsave(&cdev->lock, flags);
+		}
 	}
 
 	spin_unlock_irqrestore(&cdev->lock, flags);
diff -urpN --no-dereference -X diffgen.ignore test-tree/drivers/usb/gadget/function/f_uac1.c milky/drivers/usb/gadget/function/f_uac1.c
--- test-tree/drivers/usb/gadget/function/f_uac1.c	2024-06-01 13:18:41.884500244 -0400
+++ milky/drivers/usb/gadget/function/f_uac1.c	2024-05-21 05:22:27.000000000 -0400
@@ -48,6 +48,19 @@ static inline struct f_uac1 *func_to_uac
 /* Number of streaming interfaces */
 #define F_AUDIO_NUM_INTERFACES		2
 
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+static struct usb_interface_assoc_descriptor iad_desc = {
+	.bLength = sizeof(iad_desc),
+	.bDescriptorType = USB_DT_INTERFACE_ASSOCIATION,
+
+	.bFirstInterface = 0,
+	.bInterfaceCount = 3,
+	.bFunctionClass = USB_CLASS_AUDIO,
+	.bFunctionSubClass = USB_SUBCLASS_AUDIOSTREAMING,
+	.bFunctionProtocol = UAC_VERSION_1,
+};
+#endif
+
 /* B.3.1  Standard AC Interface Descriptor */
 static struct usb_interface_descriptor ac_interface_desc = {
 	.bLength =		USB_DT_INTERFACE_SIZE,
@@ -247,6 +260,9 @@ static struct uac_iso_endpoint_descripto
 };
 
 static struct usb_descriptor_header *f_audio_desc[] = {
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	(struct usb_descriptor_header *) &iad_desc,
+#endif
 	(struct usb_descriptor_header *)&ac_interface_desc,
 	(struct usb_descriptor_header *)&ac_header_desc,
 
@@ -523,6 +539,9 @@ static int f_audio_bind(struct usb_confi
 	us = usb_gstrings_attach(cdev, uac1_strings, ARRAY_SIZE(strings_uac1));
 	if (IS_ERR(us))
 		return PTR_ERR(us);
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	iad_desc.iFunction = us[STR_AC_IF].id;
+#endif
 	ac_interface_desc.iInterface = us[STR_AC_IF].id;
 	usb_out_it_desc.iTerminal = us[STR_USB_OUT_IT].id;
 	usb_out_it_desc.iChannelNames = us[STR_USB_OUT_IT_CH_NAMES].id;
@@ -559,6 +578,9 @@ static int f_audio_bind(struct usb_confi
 	status = usb_interface_id(c, f);
 	if (status < 0)
 		goto fail;
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	iad_desc.bFirstInterface = status;
+#endif
 	ac_interface_desc.bInterfaceNumber = status;
 	uac1->ac_intf = status;
 	uac1->ac_alt = 0;
diff -urpN --no-dereference -X diffgen.ignore test-tree/drivers/usb/gadget/function/u_audio.c milky/drivers/usb/gadget/function/u_audio.c
--- test-tree/drivers/usb/gadget/function/u_audio.c	2024-06-01 13:18:41.884500244 -0400
+++ milky/drivers/usb/gadget/function/u_audio.c	2024-05-21 05:22:27.000000000 -0400
@@ -23,6 +23,49 @@
 #define PRD_SIZE_MAX	PAGE_SIZE
 #define MIN_PERIODS	4
 
+#if IS_ENABLED(CONFIG_ARCH_CVITEK) && defined(UAC1_DBG)
+
+#define dprintk(fmt, arg...)	pr_debug(KERN_DEBUG "%s: " fmt, __func__, ## arg)
+
+#define UAC_DBG_NUM	40
+struct uac_dbg_s {
+	struct timeval	time;
+	struct usb_request req;
+};
+
+static struct uac_dbg_s uac_dbg[UAC_DBG_NUM];
+static int uac_dbg_idx = UAC_DBG_NUM;
+module_param(uac_dbg_idx, int, 0644);
+
+static void uac_dbg_log(struct usb_request *req)
+{
+	struct timeval tv;
+	struct uac_dbg_s *dbg;
+
+	if (uac_dbg_idx >= UAC_DBG_NUM)
+		return;
+
+	do_gettimeofday(&tv);
+	dbg = &uac_dbg[uac_dbg_idx];
+	memcpy(&dbg->req, req, sizeof(struct usb_request));
+	dbg->time.tv_sec = tv.tv_sec;
+	dbg->time.tv_usec = tv.tv_usec;
+	uac_dbg_idx++;
+
+	if (uac_dbg_idx == UAC_DBG_NUM) {
+		int i;
+		u64 time_0;
+
+		for (i = 0; i < uac_dbg_idx; i++) {
+			//time_0 = (uac_dbg[i].time.tv_sec * STOUS) + uac_dbg[i].time.tv_usec;
+			time_0 = uac_dbg[i].time.tv_usec;
+			dprintk("[%d - %llu] status = %d, length = %d\n", i,
+					time_0, uac_dbg[i].req.status, uac_dbg[i].req.actual);
+		}
+	}
+}
+#endif
+
 struct uac_req {
 	struct uac_rtd_params *pp; /* parent param */
 	struct usb_request *req;
@@ -92,6 +135,9 @@ static void u_audio_iso_complete(struct
 	if (!prm->ep_enabled || req->status == -ESHUTDOWN)
 		return;
 
+#if IS_ENABLED(CONFIG_ARCH_CVITEK) && defined(UAC1_DBG)
+	uac_dbg_log(req);
+#endif
 	/*
 	 * We can't really do much about bad xfers.
 	 * Afterall, the ISOCH xfers could fail legitimately.
@@ -360,6 +406,9 @@ int u_audio_start_capture(struct g_audio
 
 	ep = audio_dev->out_ep;
 	prm = &uac->c_prm;
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	usb_ep_disable(ep);
+#endif
 	config_ep_by_speed(gadget, &audio_dev->func, ep);
 	req_len = ep->maxpacket;
 
@@ -413,6 +462,9 @@ int u_audio_start_playback(struct g_audi
 
 	ep = audio_dev->in_ep;
 	prm = &uac->p_prm;
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	usb_ep_disable(ep);
+#endif
 	config_ep_by_speed(gadget, &audio_dev->func, ep);
 
 	ep_desc = ep->desc;
diff -urpN --no-dereference -X diffgen.ignore test-tree/drivers/usb/gadget/function/u_uac1.h milky/drivers/usb/gadget/function/u_uac1.h
--- test-tree/drivers/usb/gadget/function/u_uac1.h	2024-06-01 13:18:41.884500244 -0400
+++ milky/drivers/usb/gadget/function/u_uac1.h	2024-05-21 05:22:27.000000000 -0400
@@ -10,15 +10,19 @@
 
 #include <linux/usb/composite.h>
 
-#define UAC1_OUT_EP_MAX_PACKET_SIZE	200
 #define UAC1_DEF_CCHMASK	0x3
 #define UAC1_DEF_CSRATE		48000
 #define UAC1_DEF_CSSIZE		2
 #define UAC1_DEF_PCHMASK	0x3
 #define UAC1_DEF_PSRATE		48000
 #define UAC1_DEF_PSSIZE		2
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+#define UAC1_OUT_EP_MAX_PACKET_SIZE	256
+#define UAC1_DEF_REQ_NUM	3
+#else
+#define UAC1_OUT_EP_MAX_PACKET_SIZE	200
 #define UAC1_DEF_REQ_NUM	2
-
+#endif
 
 struct f_uac1_opts {
 	struct usb_function_instance	func_inst;
diff -urpN --no-dereference -X diffgen.ignore test-tree/drivers/usb/gadget/function/uvc_configfs.c milky/drivers/usb/gadget/function/uvc_configfs.c
--- test-tree/drivers/usb/gadget/function/uvc_configfs.c	2024-06-01 13:18:41.888500232 -0400
+++ milky/drivers/usb/gadget/function/uvc_configfs.c	2024-05-21 05:22:27.000000000 -0400
@@ -767,11 +767,13 @@ static const struct uvcg_config_group_ty
 static const char * const uvcg_format_names[] = {
 	"uncompressed",
 	"mjpeg",
+	"framebased",
 };
 
 enum uvcg_format_type {
 	UVCG_UNCOMPRESSED = 0,
 	UVCG_MJPEG,
+	UVCG_FRAMEBASED,
 };
 
 struct uvcg_format {
@@ -1077,9 +1079,15 @@ struct uvcg_frame {
 		u16	w_height;
 		u32	dw_min_bit_rate;
 		u32	dw_max_bit_rate;
+		/*
+		 * dw_max_video_frame_buffer_size is only for uncompressed and
+		 * mjpeg format
+		 */
 		u32	dw_max_video_frame_buffer_size;
 		u32	dw_default_frame_interval;
 		u8	b_frame_interval_type;
+		/* dw_bytes_perline is only for framebased format */
+		u32	dw_bytes_perline;
 	} __attribute__((packed)) frame;
 	u32 *dw_frame_interval;
 };
@@ -1190,7 +1198,7 @@ UVCG_FRAME_ATTR(dw_min_bit_rate, dwMinBi
 UVCG_FRAME_ATTR(dw_max_bit_rate, dwMaxBitRate, 32);
 UVCG_FRAME_ATTR(dw_max_video_frame_buffer_size, dwMaxVideoFrameBufferSize, 32);
 UVCG_FRAME_ATTR(dw_default_frame_interval, dwDefaultFrameInterval, 32);
-
+UVCG_FRAME_ATTR(dw_bytes_perline, dwBytesPerLine, 32);
 #undef UVCG_FRAME_ATTR
 
 static ssize_t uvcg_frame_dw_frame_interval_show(struct config_item *item,
@@ -1324,7 +1332,7 @@ end:
 
 UVC_ATTR(uvcg_frame_, dw_frame_interval, dwFrameInterval);
 
-static struct configfs_attribute *uvcg_frame_attrs[] = {
+static struct configfs_attribute *uvcg_frame_attrs1[] = {
 	&uvcg_frame_attr_b_frame_index,
 	&uvcg_frame_attr_bm_capabilities,
 	&uvcg_frame_attr_w_width,
@@ -1337,9 +1345,28 @@ static struct configfs_attribute *uvcg_f
 	NULL,
 };
 
-static const struct config_item_type uvcg_frame_type = {
+static struct configfs_attribute *uvcg_frame_attrs2[] = {
+	&uvcg_frame_attr_b_frame_index,
+	&uvcg_frame_attr_bm_capabilities,
+	&uvcg_frame_attr_w_width,
+	&uvcg_frame_attr_w_height,
+	&uvcg_frame_attr_dw_min_bit_rate,
+	&uvcg_frame_attr_dw_max_bit_rate,
+	&uvcg_frame_attr_dw_default_frame_interval,
+	&uvcg_frame_attr_dw_frame_interval,
+	&uvcg_frame_attr_dw_bytes_perline,
+	NULL,
+};
+
+static const struct config_item_type uvcg_frame_type1 = {
 	.ct_item_ops	= &uvcg_config_item_ops,
-	.ct_attrs	= uvcg_frame_attrs,
+	.ct_attrs	= uvcg_frame_attrs1,
+	.ct_owner	= THIS_MODULE,
+};
+
+static const struct config_item_type uvcg_frame_type2 = {
+	.ct_item_ops	= &uvcg_config_item_ops,
+	.ct_attrs	= uvcg_frame_attrs2,
 	.ct_owner	= THIS_MODULE,
 };
 
@@ -1363,6 +1390,7 @@ static struct config_item *uvcg_frame_ma
 	h->frame.dw_max_bit_rate		= 55296000;
 	h->frame.dw_max_video_frame_buffer_size	= 460800;
 	h->frame.dw_default_frame_interval	= 666666;
+	h->frame.dw_bytes_perline = 0;
 
 	opts_item = group->cg_item.ci_parent->ci_parent->ci_parent;
 	opts = to_f_uvc_opts(opts_item);
@@ -1375,6 +1403,9 @@ static struct config_item *uvcg_frame_ma
 	} else if (fmt->type == UVCG_MJPEG) {
 		h->frame.b_descriptor_subtype = UVC_VS_FRAME_MJPEG;
 		h->fmt_type = UVCG_MJPEG;
+	} else if (fmt->type == UVCG_FRAMEBASED) {
+		h->frame.b_descriptor_subtype = UVC_VS_FRAME_FRAME_BASED;
+		h->fmt_type = UVCG_FRAMEBASED;
 	} else {
 		mutex_unlock(&opts->lock);
 		kfree(h);
@@ -1383,7 +1414,10 @@ static struct config_item *uvcg_frame_ma
 	++fmt->num_frames;
 	mutex_unlock(&opts->lock);
 
-	config_item_init_type_name(&h->item, name, &uvcg_frame_type);
+	if (fmt->type == UVCG_FRAMEBASED)
+		config_item_init_type_name(&h->item, name, &uvcg_frame_type2);
+	else
+		config_item_init_type_name(&h->item, name, &uvcg_frame_type1);
 
 	return &h->item;
 }
@@ -1413,7 +1447,8 @@ static void uvcg_format_set_indices(stru
 	list_for_each_entry(ci, &fmt->cg_children, ci_entry) {
 		struct uvcg_frame *frm;
 
-		if (ci->ci_type != &uvcg_frame_type)
+		if (ci->ci_type != &uvcg_frame_type1 &&
+		    ci->ci_type != &uvcg_frame_type2)
 			continue;
 
 		frm = to_uvcg_frame(ci);
@@ -1856,6 +1891,260 @@ static const struct uvcg_config_group_ty
 	.name = "mjpeg",
 };
 
+ /* -----------------------------------------------------------------------------
+ * streaming/framebased/<NAME>
+ */
+
+struct uvcg_framebased {
+	struct uvcg_format		fmt;
+	struct uvc_format_framebased	desc;
+};
+
+static struct uvcg_framebased *to_uvcg_framebased(struct config_item *item)
+{
+	return container_of(
+		container_of(to_config_group(item), struct uvcg_format, group),
+		struct uvcg_framebased, fmt);
+}
+
+static struct configfs_group_operations uvcg_framebased_group_ops = {
+	.make_item		= uvcg_frame_make,
+	.drop_item		= uvcg_frame_drop,
+};
+
+#define UVCG_FRAMEBASED_ATTR_RO(cname, aname, bits)			\
+static ssize_t uvcg_framebased_##cname##_show(struct config_item *item,\
+					char *page)			\
+{									\
+	struct uvcg_framebased *u = to_uvcg_framebased(item);		\
+	struct f_uvc_opts *opts;					\
+	struct config_item *opts_item;					\
+	struct mutex *su_mutex = &u->fmt.group.cg_subsys->su_mutex;	\
+	int result;							\
+									\
+	mutex_lock(su_mutex); /* for navigating configfs hierarchy */	\
+									\
+	opts_item = u->fmt.group.cg_item.ci_parent->ci_parent->ci_parent;\
+	opts = to_f_uvc_opts(opts_item);				\
+									\
+	mutex_lock(&opts->lock);					\
+	result = sprintf(page, "%u\n", le##bits##_to_cpu(u->desc.aname));\
+	mutex_unlock(&opts->lock);					\
+									\
+	mutex_unlock(su_mutex);						\
+	return result;							\
+}									\
+									\
+UVC_ATTR_RO(uvcg_framebased_, cname, aname)
+
+#define UVCG_FRAMEBASED_ATTR(cname, aname, bits)			\
+static ssize_t uvcg_framebased_##cname##_show(struct config_item *item,\
+				char *page)\
+{									\
+	struct uvcg_framebased *u = to_uvcg_framebased(item);		\
+	struct f_uvc_opts *opts;					\
+	struct config_item *opts_item;					\
+	struct mutex *su_mutex = &u->fmt.group.cg_subsys->su_mutex;	\
+	int result;							\
+									\
+	mutex_lock(su_mutex); /* for navigating configfs hierarchy */	\
+									\
+	opts_item = u->fmt.group.cg_item.ci_parent->ci_parent->ci_parent;\
+	opts = to_f_uvc_opts(opts_item);				\
+									\
+	mutex_lock(&opts->lock);					\
+	result = sprintf(page, "%u\n", le##bits##_to_cpu(u->desc.aname));\
+	mutex_unlock(&opts->lock);					\
+									\
+	mutex_unlock(su_mutex);						\
+	return result;							\
+}									\
+									\
+static ssize_t								\
+uvcg_framebased_##cname##_store(struct config_item *item,		\
+			   const char *page, size_t len)		\
+{									\
+	struct uvcg_framebased *u = to_uvcg_framebased(item);		\
+	struct f_uvc_opts *opts;					\
+	struct config_item *opts_item;					\
+	struct mutex *su_mutex = &u->fmt.group.cg_subsys->su_mutex;	\
+	int ret;							\
+	u8 num;								\
+									\
+	mutex_lock(su_mutex); /* for navigating configfs hierarchy */	\
+									\
+	opts_item = u->fmt.group.cg_item.ci_parent->ci_parent->ci_parent;\
+	opts = to_f_uvc_opts(opts_item);				\
+									\
+	mutex_lock(&opts->lock);					\
+	if (u->fmt.linked || opts->refcnt) {				\
+		ret = -EBUSY;						\
+		goto end;						\
+	}								\
+									\
+	ret = kstrtou8(page, 0, &num);					\
+	if (ret)							\
+		goto end;						\
+									\
+	if (num > 255) {						\
+		ret = -EINVAL;						\
+		goto end;						\
+	}								\
+	u->desc.aname = num;						\
+	ret = len;							\
+end:									\
+	mutex_unlock(&opts->lock);					\
+	mutex_unlock(su_mutex);						\
+	return ret;							\
+}									\
+									\
+UVC_ATTR(uvcg_framebased_, cname, aname)
+
+UVCG_FRAMEBASED_ATTR_RO(b_format_index, bFormatIndex, 8);
+UVCG_FRAMEBASED_ATTR_RO(b_bits_per_pixel, bBitsPerPixel, 8);
+UVCG_FRAMEBASED_ATTR(b_default_frame_index, bDefaultFrameIndex, 8);
+UVCG_FRAMEBASED_ATTR_RO(b_aspect_ratio_x, bAspectRatioX, 8);
+UVCG_FRAMEBASED_ATTR_RO(b_aspect_ratio_y, bAspectRatioY, 8);
+UVCG_FRAMEBASED_ATTR_RO(bm_interface_flags, bmInterfaceFlags, 8);
+
+#undef UVCG_FRAMEBASED_ATTR
+#undef UVCG_FRAMEBASED_ATTR_RO
+
+static ssize_t uvcg_framebased_guid_format_show(struct config_item *item,
+							char *page)
+{
+	struct uvcg_framebased *ch = to_uvcg_framebased(item);
+	struct f_uvc_opts *opts;
+	struct config_item *opts_item;
+	struct mutex *su_mutex = &ch->fmt.group.cg_subsys->su_mutex;
+
+	mutex_lock(su_mutex); /* for navigating configfs hierarchy */
+
+	opts_item = ch->fmt.group.cg_item.ci_parent->ci_parent->ci_parent;
+	opts = to_f_uvc_opts(opts_item);
+
+	mutex_lock(&opts->lock);
+	memcpy(page, ch->desc.guidFormat, sizeof(ch->desc.guidFormat));
+	mutex_unlock(&opts->lock);
+
+	mutex_unlock(su_mutex);
+
+	return sizeof(ch->desc.guidFormat);
+}
+
+static ssize_t uvcg_framebased_guid_format_store(struct config_item *item,
+						   const char *page, size_t len)
+{
+	struct uvcg_framebased *ch = to_uvcg_framebased(item);
+	struct f_uvc_opts *opts;
+	struct config_item *opts_item;
+	struct mutex *su_mutex = &ch->fmt.group.cg_subsys->su_mutex;
+	int ret;
+
+	mutex_lock(su_mutex); /* for navigating configfs hierarchy */
+
+	opts_item = ch->fmt.group.cg_item.ci_parent->ci_parent->ci_parent;
+	opts = to_f_uvc_opts(opts_item);
+
+	mutex_lock(&opts->lock);
+	if (ch->fmt.linked || opts->refcnt) {
+		ret = -EBUSY;
+		goto end;
+	}
+
+	memcpy(ch->desc.guidFormat, page,
+	       min(sizeof(ch->desc.guidFormat), len));
+	ret = sizeof(ch->desc.guidFormat);
+
+end:
+	mutex_unlock(&opts->lock);
+	mutex_unlock(su_mutex);
+	return ret;
+}
+
+UVC_ATTR(uvcg_framebased_, guid_format, guidFormat);
+
+static inline ssize_t
+uvcg_framebased_bma_controls_show(struct config_item *item, char *page)
+{
+	struct uvcg_framebased *u = to_uvcg_framebased(item);
+
+	return uvcg_format_bma_controls_show(&u->fmt, page);
+}
+
+static inline ssize_t
+uvcg_framebased_bma_controls_store(struct config_item *item,
+				     const char *page, size_t len)
+{
+	struct uvcg_framebased *u = to_uvcg_framebased(item);
+
+	return uvcg_format_bma_controls_store(&u->fmt, page, len);
+}
+
+UVC_ATTR(uvcg_framebased_, bma_controls, bmaControls);
+
+static struct configfs_attribute *uvcg_framebased_attrs[] = {
+	&uvcg_framebased_attr_b_format_index,
+	&uvcg_framebased_attr_b_default_frame_index,
+	&uvcg_framebased_attr_b_bits_per_pixel,
+	&uvcg_framebased_attr_b_aspect_ratio_x,
+	&uvcg_framebased_attr_b_aspect_ratio_y,
+	&uvcg_framebased_attr_bm_interface_flags,
+	&uvcg_framebased_attr_bma_controls,
+	&uvcg_framebased_attr_guid_format,
+	NULL,
+};
+
+static const struct config_item_type uvcg_framebased_type = {
+	.ct_item_ops	= &uvcg_config_item_ops,
+	.ct_group_ops	= &uvcg_framebased_group_ops,
+	.ct_attrs	= uvcg_framebased_attrs,
+	.ct_owner	= THIS_MODULE,
+};
+
+static struct config_group *uvcg_framebased_make(struct config_group *group,
+						   const char *name)
+{
+	static char guid[] = { /*Declear frame frame based as H264*/
+		'H',  '2',  '6',  '4', 0x00, 0x00, 0x10, 0x00,
+		0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
+	};
+	struct uvcg_framebased *f;
+
+	f = kzalloc(sizeof(*f), GFP_KERNEL);
+	if (!f)
+		return ERR_PTR(-ENOMEM);
+
+	f->desc.bLength			= UVC_DT_FORMAT_FRAMEBASED_SIZE;
+	f->desc.bDescriptorType		= USB_DT_CS_INTERFACE;
+	f->desc.bDescriptorSubType	= UVC_VS_FORMAT_FRAME_BASED;
+	memcpy(f->desc.guidFormat, guid, sizeof(guid));
+	f->desc.bBitsPerPixel		= 0;
+	f->desc.bDefaultFrameIndex	= 1;
+	f->desc.bAspectRatioX		= 0;
+	f->desc.bAspectRatioY		= 0;
+	f->desc.bmInterfaceFlags	= 0;
+	f->desc.bCopyProtect		= 0;
+
+	f->fmt.type = UVCG_FRAMEBASED;
+	config_group_init_type_name(&f->fmt.group, name,
+				    &uvcg_framebased_type);
+
+	return &f->fmt.group;
+}
+
+static struct configfs_group_operations uvcg_framebased_grp_ops = {
+	.make_group		= uvcg_framebased_make,
+};
+static const struct uvcg_config_group_type uvcg_framebased_grp_type = {
+	.type = {
+		.ct_item_ops	= &uvcg_config_item_ops,
+		.ct_group_ops	= &uvcg_framebased_grp_ops,
+		.ct_owner	= THIS_MODULE,
+	},
+	.name = "framebased",
+};
+
 /* -----------------------------------------------------------------------------
  * streaming/color_matching/default
  */
@@ -2049,6 +2338,10 @@ static int __uvcg_cnt_strm(void *priv1,
 				container_of(fmt, struct uvcg_mjpeg, fmt);
 
 			*size += sizeof(m->desc);
+		} else if (fmt->type == UVCG_FRAMEBASED) {
+			struct uvcg_framebased *f =
+				container_of(fmt, struct uvcg_framebased, fmt);
+			*size += sizeof(f->desc);
 		} else {
 			return -EINVAL;
 		}
@@ -2059,6 +2352,11 @@ static int __uvcg_cnt_strm(void *priv1,
 		int sz = sizeof(frm->dw_frame_interval);
 
 		*size += sizeof(frm->frame);
+		/*
+		 * framebased has duplicate member with uncompressed and
+		 * mjpeg, so minus it
+		 */
+		*size -= sizeof(u32);
 		*size += frm->frame.b_frame_interval_type * sz;
 	}
 	break;
@@ -2069,6 +2367,27 @@ static int __uvcg_cnt_strm(void *priv1,
 	return 0;
 }
 
+static int __uvcg_copy_framebased_desc(void *dest, struct uvcg_frame *frm,
+				       int sz)
+{
+	struct uvc_frame_framebased *desc = dest;
+
+	desc->bLength = frm->frame.b_length;
+	desc->bDescriptorType = frm->frame.b_descriptor_type;
+	desc->bDescriptorSubType = frm->frame.b_descriptor_subtype;
+	desc->bFrameIndex = frm->frame.b_frame_index;
+	desc->bmCapabilities = frm->frame.bm_capabilities;
+	desc->wWidth = frm->frame.w_width;
+	desc->wHeight = frm->frame.w_height;
+	desc->dwMinBitRate = frm->frame.dw_min_bit_rate;
+	desc->dwMaxBitRate = frm->frame.dw_max_bit_rate;
+	desc->dwDefaultFrameInterval = frm->frame.dw_default_frame_interval;
+	desc->bFrameIntervalType = frm->frame.b_frame_interval_type;
+	desc->dwBytesPerLine = frm->frame.dw_bytes_perline;
+
+	return 0;
+}
+
 /*
  * Fill an array of streaming descriptors.
  *
@@ -2123,6 +2442,15 @@ static int __uvcg_fill_strm(void *priv1,
 			m->desc.bNumFrameDescriptors = fmt->num_frames;
 			memcpy(*dest, &m->desc, sizeof(m->desc));
 			*dest += sizeof(m->desc);
+		} else if (fmt->type == UVCG_FRAMEBASED) {
+			struct uvcg_framebased *f =
+				container_of(fmt, struct uvcg_framebased,
+					     fmt);
+
+			f->desc.bFormatIndex = n + 1;
+			f->desc.bNumFrameDescriptors = fmt->num_frames;
+			memcpy(*dest, &f->desc, sizeof(f->desc));
+			*dest += sizeof(f->desc);
 		} else {
 			return -EINVAL;
 		}
@@ -2132,8 +2460,11 @@ static int __uvcg_fill_strm(void *priv1,
 		struct uvcg_frame *frm = priv1;
 		struct uvc_descriptor_header *h = *dest;
 
-		sz = sizeof(frm->frame);
-		memcpy(*dest, &frm->frame, sz);
+		sz = sizeof(frm->frame) - 4;
+		if (frm->fmt_type != UVCG_FRAMEBASED)
+			memcpy(*dest, &frm->frame, sz);
+		else
+			__uvcg_copy_framebased_desc(*dest, frm, sz);
 		*dest += sz;
 		sz = frm->frame.b_frame_interval_type *
 			sizeof(*frm->dw_frame_interval);
@@ -2145,6 +2476,9 @@ static int __uvcg_fill_strm(void *priv1,
 		else if (frm->fmt_type == UVCG_MJPEG)
 			h->bLength = UVC_DT_FRAME_MJPEG_SIZE(
 				frm->frame.b_frame_interval_type);
+		else if (frm->fmt_type == UVCG_FRAMEBASED)
+			h->bLength = UVC_DT_FRAME_FRAMEBASED_SIZE(
+				 frm->frame.b_frame_interval_type);
 	}
 	break;
 	}
@@ -2357,6 +2691,7 @@ static const struct uvcg_config_group_ty
 		&uvcg_streaming_header_grp_type,
 		&uvcg_uncompressed_grp_type,
 		&uvcg_mjpeg_grp_type,
+		&uvcg_framebased_grp_type,
 		&uvcg_color_matching_grp_type,
 		&uvcg_streaming_class_grp_type,
 		NULL,
diff -urpN --no-dereference -X diffgen.ignore test-tree/drivers/usb/gadget/function/uvc_v4l2.c milky/drivers/usb/gadget/function/uvc_v4l2.c
--- test-tree/drivers/usb/gadget/function/uvc_v4l2.c	2024-06-01 13:18:41.888500232 -0400
+++ milky/drivers/usb/gadget/function/uvc_v4l2.c	2024-05-21 05:22:27.000000000 -0400
@@ -58,6 +58,9 @@ struct uvc_format {
 static struct uvc_format uvc_formats[] = {
 	{ 16, V4L2_PIX_FMT_YUYV  },
 	{ 0,  V4L2_PIX_FMT_MJPEG },
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	{ 0,  V4L2_PIX_FMT_H264 },
+#endif
 };
 
 static int
diff -urpN --no-dereference -X diffgen.ignore test-tree/drivers/usb/gadget/function/uvc_video.c milky/drivers/usb/gadget/function/uvc_video.c
--- test-tree/drivers/usb/gadget/function/uvc_video.c	2024-06-01 13:18:41.888500232 -0400
+++ milky/drivers/usb/gadget/function/uvc_video.c	2024-05-21 05:22:27.000000000 -0400
@@ -12,13 +12,16 @@
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
 #include <linux/usb/video.h>
-
+#if IS_ENABLED(CONFIG_USB_UVCG_SG_TRANSFER)
+#include <linux/scatterlist.h>
+#endif
 #include <media/v4l2-dev.h>
 
 #include "uvc.h"
 #include "uvc_queue.h"
 #include "uvc_video.h"
 
+#define UVCG_MAX_SG_NUM		64	// 8ms in 125us interval.
 /* --------------------------------------------------------------------------
  * Video codecs
  */
@@ -94,6 +97,7 @@ uvc_video_encode_bulk(struct usb_request
 		video->payload_size = 0;
 }
 
+#if !IS_ENABLED(CONFIG_USB_UVCG_SG_TRANSFER)
 static void
 uvc_video_encode_isoc(struct usb_request *req, struct uvc_video *video,
 		struct uvc_buffer *buf)
@@ -120,7 +124,44 @@ uvc_video_encode_isoc(struct usb_request
 		video->fid ^= UVC_STREAM_FID;
 	}
 }
+#else
+static void
+uvc_video_encode_isoc(struct usb_request *req, struct uvc_video *video,
+		struct uvc_buffer *buf)
+{
+	int i;
+	struct scatterlist *sg;
 
+	req->length = 0;
+
+	for_each_sg(req->sg, sg, UVCG_MAX_SG_NUM, i) {
+		void *mem = sg_virt(sg);
+		int len = video->req_size;
+		int ret;
+
+		/* Add the header. */
+		ret = uvc_video_encode_header(video, buf, mem, len);
+		mem += ret;
+		len -= ret;
+		/* Process video data. */
+		ret = uvc_video_encode_data(video, buf, mem, len);
+		len -= ret;
+
+		sg->length = video->req_size - len;
+		req->length += sg->length;
+
+		if (buf->bytesused == video->queue.buf_used) {
+			video->queue.buf_used = 0;
+			buf->state = UVC_BUF_STATE_DONE;
+			uvcg_queue_next_buffer(&video->queue, buf);
+			video->fid ^= UVC_STREAM_FID;
+			i++;
+			break;
+		}
+	}
+	req->num_sgs = i;
+}
+#endif
 /* --------------------------------------------------------------------------
  * Request handling
  */
@@ -199,6 +240,9 @@ uvc_video_alloc_requests(struct uvc_vide
 {
 	unsigned int req_size;
 	unsigned int i;
+#if IS_ENABLED(CONFIG_USB_UVCG_SG_TRANSFER)
+	unsigned int j;
+#endif
 	int ret = -ENOMEM;
 
 	BUG_ON(video->req_size);
@@ -206,7 +250,7 @@ uvc_video_alloc_requests(struct uvc_vide
 	req_size = video->ep->maxpacket
 		 * max_t(unsigned int, video->ep->maxburst, 1)
 		 * (video->ep->mult);
-
+#if !IS_ENABLED(CONFIG_USB_UVCG_SG_TRANSFER)
 	for (i = 0; i < UVC_NUM_REQUESTS; ++i) {
 		video->req_buffer[i] = kmalloc(req_size, GFP_KERNEL);
 		if (video->req_buffer[i] == NULL)
@@ -225,6 +269,32 @@ uvc_video_alloc_requests(struct uvc_vide
 	}
 
 	video->req_size = req_size;
+#else
+	req_size = ALIGN(req_size, 32);
+	for (i = 0; i < UVC_NUM_REQUESTS; ++i) {
+		video->req_buffer[i] = kmalloc(req_size * UVCG_MAX_SG_NUM, GFP_KERNEL);
+		if (video->req_buffer[i] == NULL)
+			goto error;
+
+		video->req[i] = usb_ep_alloc_request(video->ep, GFP_KERNEL);
+		if (video->req[i] == NULL)
+			goto error;
+		video->req[i]->sg = kmalloc(sizeof(struct scatterlist) * UVCG_MAX_SG_NUM, GFP_KERNEL);
+		if (video->req[i]->sg == NULL)
+			goto error;
+		sg_init_table(video->req[i]->sg, UVCG_MAX_SG_NUM);
+		video->req[i]->buf = video->req_buffer[i];
+		for (j = 0; j < UVCG_MAX_SG_NUM; j++)
+			sg_set_buf(&video->req[i]->sg[j], video->req[i]->buf + req_size * j, 0);
+		video->req[i]->num_sgs = 0;
+		video->req[i]->length = 0;
+		video->req[i]->complete = uvc_video_complete;
+		video->req[i]->context = video;
+		list_add_tail(&video->req[i]->list, &video->req_free);
+	}
+
+	video->req_size = req_size;
+#endif
 
 	return 0;
 
@@ -278,6 +348,11 @@ static void uvcg_video_pump(struct work_
 
 		video->encode(req, video, buf);
 
+		if (!video->ep->enabled) {
+			spin_unlock_irqrestore(&queue->irqlock, flags);
+			uvcg_queue_cancel(queue, 0);
+			break;
+		}
 		/* Queue the USB request */
 		ret = uvcg_video_ep_queue(video, req);
 		spin_unlock_irqrestore(&queue->irqlock, flags);
diff -urpN --no-dereference -X diffgen.ignore test-tree/drivers/usb/gadget/udc/core.c milky/drivers/usb/gadget/udc/core.c
--- test-tree/drivers/usb/gadget/udc/core.c	2024-06-01 13:18:41.892500219 -0400
+++ milky/drivers/usb/gadget/udc/core.c	2024-05-21 05:22:27.000000000 -0400
@@ -18,6 +18,9 @@
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
 #include <linux/usb.h>
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+#include <linux/usb/otg.h>
+#endif
 
 #include "trace.h"
 
@@ -29,6 +32,7 @@
  * @list: for use by the udc class driver
  * @vbus: for udcs who care about vbus status, this value is real vbus status;
  * for udcs who do not care about vbus status, this value is always true
+ * @is_otg - we're registered with OTG core and it takes care of UDC start/stop
  *
  * This represents the internal data structure which is used by the UDC-class
  * to hold information about udc driver and gadget together.
@@ -39,6 +43,9 @@ struct usb_udc {
 	struct device			dev;
 	struct list_head		list;
 	bool				vbus;
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+	bool				is_otg;
+#endif
 };
 
 static struct class *udc_class;
@@ -1125,6 +1132,78 @@ static inline void usb_gadget_udc_set_sp
 	}
 }
 
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+/**
+ * usb_gadget_start - start the usb gadget controller and connect to bus
+ * @gadget: the gadget device to start
+ *
+ * This is external API for use by OTG core.
+ *
+ * Start the usb device controller and connect to bus (enable pull).
+ */
+static int usb_gadget_start(struct usb_gadget *gadget)
+{
+	int ret;
+	struct usb_udc *udc = NULL;
+
+	dev_dbg(&gadget->dev, "%s\n", __func__);
+	mutex_lock(&udc_lock);
+	list_for_each_entry(udc, &udc_list, list)
+		if (udc->gadget == gadget)
+			goto found;
+
+	dev_err(gadget->dev.parent, "%s: gadget not registered.\n",
+		__func__);
+	mutex_unlock(&udc_lock);
+	return -EINVAL;
+
+found:
+	ret = usb_gadget_udc_start(udc);
+	if (ret)
+		dev_err(&udc->dev, "USB Device Controller didn't start: %d\n",
+			ret);
+	else
+		usb_udc_connect_control(udc);
+
+	mutex_unlock(&udc_lock);
+
+	return ret;
+}
+
+/**
+ * usb_gadget_stop - disconnect from bus and stop the usb gadget
+ * @gadget: The gadget device we want to stop
+ *
+ * This is external API for use by OTG core.
+ *
+ * Disconnect from the bus (disable pull) and stop the
+ * gadget controller.
+ */
+static int usb_gadget_stop(struct usb_gadget *gadget)
+{
+	struct usb_udc *udc = NULL;
+
+	dev_dbg(&gadget->dev, "%s\n", __func__);
+	mutex_lock(&udc_lock);
+	list_for_each_entry(udc, &udc_list, list)
+		if (udc->gadget == gadget)
+			goto found;
+
+	dev_err(gadget->dev.parent, "%s: gadget not registered.\n",
+		__func__);
+	mutex_unlock(&udc_lock);
+	return -EINVAL;
+
+found:
+	usb_gadget_disconnect(udc->gadget);
+	udc->driver->disconnect(udc->gadget);
+	usb_gadget_udc_stop(udc);
+	mutex_unlock(&udc_lock);
+
+	return 0;
+}
+#endif
+
 /**
  * usb_udc_release - release the usb_udc struct
  * @dev: the dev member within usb_udc
@@ -1336,11 +1415,26 @@ static void usb_gadget_remove_driver(str
 
 	kobject_uevent(&udc->dev.kobj, KOBJ_CHANGE);
 
+#if !defined(CONFIG_CVITEK_USB_LEGACY)
 	usb_gadget_disconnect(udc->gadget);
 	if (udc->gadget->irq)
 		synchronize_irq(udc->gadget->irq);
 	udc->driver->unbind(udc->gadget);
 	usb_gadget_udc_stop(udc);
+#else
+	/* If OTG, the otg core ensures UDC is stopped on unregister */
+	if (udc->is_otg) {
+		mutex_unlock(&udc_lock);
+		usb_otg_unregister_gadget(udc->gadget);
+		mutex_lock(&udc_lock);
+		udc->driver->unbind(udc->gadget);
+	} else {
+		usb_gadget_disconnect(udc->gadget);
+		udc->driver->disconnect(udc->gadget);
+		udc->driver->unbind(udc->gadget);
+		usb_gadget_udc_stop(udc);
+	}
+#endif
 
 	udc->driver = NULL;
 	udc->dev.driver = NULL;
@@ -1397,6 +1491,13 @@ EXPORT_SYMBOL_GPL(usb_del_gadget_udc);
 
 /* ------------------------------------------------------------------------- */
 
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+struct otg_gadget_ops otg_gadget_intf = {
+	.start = usb_gadget_start,
+	.stop = usb_gadget_stop,
+};
+#endif
+
 static int udc_bind_to_driver(struct usb_udc *udc, struct usb_gadget_driver *driver)
 {
 	int ret;
@@ -1413,6 +1514,7 @@ static int udc_bind_to_driver(struct usb
 	ret = driver->bind(udc->gadget, driver);
 	if (ret)
 		goto err1;
+#if !defined(CONFIG_CVITEK_USB_LEGACY)
 	ret = usb_gadget_udc_start(udc);
 	if (ret) {
 		driver->unbind(udc->gadget);
@@ -1420,6 +1522,20 @@ static int udc_bind_to_driver(struct usb
 	}
 	usb_udc_connect_control(udc);
 
+#else
+	/* If OTG, the otg core starts the UDC when needed */
+	mutex_unlock(&udc_lock);
+	udc->is_otg = !usb_otg_register_gadget(udc->gadget, &otg_gadget_intf);
+	mutex_lock(&udc_lock);
+	if (!udc->is_otg) {
+		ret = usb_gadget_udc_start(udc);
+		if (ret) {
+			driver->unbind(udc->gadget);
+			goto err1;
+		}
+		usb_udc_connect_control(udc);
+	}
+#endif
 	kobject_uevent(&udc->dev.kobj, KOBJ_CHANGE);
 	return 0;
 err1:
@@ -1538,6 +1654,13 @@ static ssize_t soft_connect_store(struct
 		return -EOPNOTSUPP;
 	}
 
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+	/* In OTG mode we don't support softconnect, but b_bus_req */
+	if (udc->is_otg) {
+		dev_err(dev, "soft-connect not supported in OTG mode\n");
+		return -EOPNOTSUPP;
+	}
+#endif
 	if (sysfs_streq(buf, "connect")) {
 		usb_gadget_udc_start(udc);
 		usb_gadget_connect(udc->gadget);
diff -urpN --no-dereference -X diffgen.ignore test-tree/drivers/usb/host/xhci.c milky/drivers/usb/host/xhci.c
--- test-tree/drivers/usb/host/xhci.c	2024-06-01 13:18:41.920500128 -0400
+++ milky/drivers/usb/host/xhci.c	2024-05-21 05:22:27.000000000 -0400
@@ -5252,6 +5252,11 @@ int xhci_gen_setup(struct usb_hcd *hcd,
 	if (xhci->quirks & XHCI_NO_64BIT_SUPPORT)
 		xhci->hcc_params &= ~BIT(0);
 
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+	/* force set 64BIT_SUPPORT */
+	xhci->hcc_params |= BIT(0);
+#endif
+
 	/* Set dma_mask and coherent_dma_mask to 64-bits,
 	 * if xHC supports 64-bit addressing */
 	if (HCC_64BIT_ADDR(xhci->hcc_params) &&
diff -urpN --no-dereference -X diffgen.ignore test-tree/drivers/usb/host/xhci-plat.c milky/drivers/usb/host/xhci-plat.c
--- test-tree/drivers/usb/host/xhci-plat.c	2024-06-01 13:18:41.916500140 -0400
+++ milky/drivers/usb/host/xhci-plat.c	2024-05-21 05:22:27.000000000 -0400
@@ -84,6 +84,10 @@ static void xhci_plat_quirks(struct devi
 	 * dev struct in order to setup MSI
 	 */
 	xhci->quirks |= XHCI_PLAT | priv->quirks;
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+	/* Use the SW bandwidth calculation. */
+	xhci->quirks |= XHCI_SW_BW_CHECKING;
+#endif
 }
 
 /* called during probe() after chip reset completes */
@@ -105,7 +109,32 @@ static int xhci_plat_start(struct usb_hc
 	return xhci_run(hcd);
 }
 
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+static int cvi_core_init_mode(struct platform_device *pdev)
+{
+	/* Bypass the bandwidth report. */
+	iowrite32((ioread32(ioremap(0x040D8098, 0x4)) | (1 << 17) | (1 << 18)),
+		ioremap(0x040D8098, 0x4));
+	return 0;
+}
+#endif
+
 #ifdef CONFIG_OF
+
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+int xhci_cvitek_init_quirk(struct usb_hcd *hcd)
+{
+
+	if (usb_hcd_is_primary_hcd(hcd))
+		cvi_core_init_mode(to_platform_device(hcd->self.controller));
+	return 0;
+}
+
+static const struct xhci_plat_priv xhci_plat_cvitek = {
+	.init_quirk = xhci_cvitek_init_quirk,
+};
+#endif
+
 static const struct xhci_plat_priv xhci_plat_marvell_armada = {
 	.init_quirk = xhci_mvebu_mbus_init_quirk,
 };
@@ -132,6 +161,11 @@ static const struct of_device_id usb_xhc
 	}, {
 		.compatible = "xhci-platform",
 	}, {
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+		.compatible = "cvitek,xhci-platform",
+		.data = &xhci_plat_cvitek,
+	}, {
+#endif
 		.compatible = "marvell,armada-375-xhci",
 		.data = &xhci_plat_marvell_armada,
 	}, {
